/*
* Copyright (c) 2019 Yellicode
*
* This Source Code Form is subject to the terms of the Mozilla Public
* License, v. 2.0. If a copy of the MPL was not distributed with this
* file, You can obtain one at http://mozilla.org/MPL/2.0/.
*/

/**
* This code was generated by a tool.
* 
* Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
*/

/**
* Enumerates all non-abstract element types in the model. Each model element has an elementType field
* with an ElementType value.
*/
export enum ElementType {
	/**
	* The element is a Association. Associations represent relationships between classes.
	*/
	association = 1,
	/**
	* Alias for ElementType.class in case the reserved 'class' is not allowed.
	*/
	_class = 2,
	/**
	* The element is a Class. A Class classifies a set of objects and specifies the features that
	* characterize the structure and behavior of those objects. A Class may have an internal structure and
	* Ports.
	*/
	class = 2,
	/**
	* The element is a Comment. A Comment is a textual annotation that can be attached to a set of
	* Elements.
	*/
	comment = 3,
	/**
	* The element is a DataType. A DataType is similar to a Class; however, instances of data type are
	* identified only by their value. If two data types have the same value, the instances are considered
	* identical.
	*/
	dataType = 4,
	/**
	* The element is a Enumeration. An Enumeration is a DataType whose values are enumerated in the model
	* as EnumerationLiterals.
	*/
	enumeration = 5,
	/**
	* The element is a EnumerationLiteral. An EnumerationLiteral is a user-defined data value for an
	* Enumeration.
	*/
	enumerationLiteral = 6,
	/**
	* The element is a Generalization. A Generalization is a taxonomic relationship between a more general
	* Classifier and a more specific Classifier. Each instance of the specific Classifier is also an
	* instance of the general Classifier.The specific Classifier inherits the features of the more general
	* Classifier. A Generalization is owned by the specific Classifier.
	*/
	generalization = 7,
	/**
	* Alias for ElementType.interface in case the reserved 'interface' is not allowed.
	*/
	_interface = 8,
	/**
	* The element is a Interface. Interfaces declare coherent services that are implemented by
	* BehavioredClassifiers that implement the Interfaces via InterfaceRealizations.
	*/
	interface = 8,
	/**
	* The element is a InterfaceRealization. An InterfaceRealization is a specialized realization
	* relationship between a BehavioredClassifier and an Interface. This relationship signifies that the
	* realizing BehavioredClassifier conforms to the contract specified by the Interface.
	*/
	interfaceRealization = 9,
	/**
	* The element is a LiteralBoolean. A LiteralBoolean is a specification of a Boolean value.
	*/
	literalBoolean = 10,
	/**
	* The element is a LiteralInteger. A LiteralInteger is a specification of an Integer value.
	*/
	literalInteger = 11,
	/**
	* The element is a LiteralNull. A LiteralNull specifies the lack of a value.
	*/
	literalNull = 12,
	/**
	* The element is a LiteralReal. A LiteralReal is a specification of a Real value.
	*/
	literalReal = 13,
	/**
	* The element is a LiteralString. A LiteralString is a specification of a String value.
	*/
	literalString = 14,
	/**
	* The element is a LiteralUnlimitedNatural. A LiteralUnlimitedNatural is a specification of an
	* UnlimitedNatural number.
	*/
	literalUnlimitedNatural = 15,
	/**
	* The element is a Model. Represents the top-level package.
	*/
	model = 16,
	/**
	* The element is a Operation. An Operation is a BehavioralFeature of a Classifier that specifies the
	* name, type, parameters, and constraints for invoking an associated Behavior. An Operation may invoke
	* both the execution of method behaviors as well as other behavioral responses.
	*/
	operation = 17,
	/**
	* The element is a Package. A package is used to group elements, and provides a namespace for the
	* grouped elements.
	* A package can have one or more profile applications to indicate which profiles have been applied.
	* Because a profile is a package, it is possible to apply a profile not only to packages, but also to
	* profiles.
	*/
	package = 18,
	/**
	* The element is a Parameter. A Parameter is a specification of an argument used to pass information
	* into or out of an invocation of a BehavioralFeature. Parameters can be treated as
	* ConnectableElements within Collaborations.
	*/
	parameter = 19,
	/**
	* The element is a PrimitiveType. A PrimitiveType defines a predefined DataType, without any
	* substructure. A PrimitiveType may have an algebra and operations defined outside of UML, for
	* example, mathematically.
	*/
	primitiveType = 20,
	/**
	* The element is a Profile. Metamodel customizations are defined in a profile, which is then applied
	* to a package. A profile can define classes, stereotypes, data types, primitive types, enumerations.
	* Stereotypes are specific metaclasses, tagged values are standard metaattributes, and profiles are
	* specific kinds of packages.
	*/
	profile = 21,
	/**
	* The element is a Property. A Property is a StructuralFeature. A Property related by ownedAttribute
	* to a Classifier (other than an association) represents an attribute and might also represent an
	* association end. It relates an instance of the Classifier to a value or set of values of the type of
	* the attribute. A Property related by memberEnd to an Association represents an end of the
	* Association. The type of the Property is the type of the end of the Association.
	*/
	property = 22,
	/**
	* The element is a Stereotype. Stereotype is a profile class which defines how an existing metaclass
	* may be extended as part of a profile. It enables the use of a platform or domain specific
	* terminology or notation in place of, or in addition to, the ones used for the extended metaclass.
	*/
	stereotype = 23
}


/**
 * UnlimitedNatural is a primitive type representing unlimited natural values.
 */
export class UnlimitedNatural {
    /**
     * Returns true if this UnlimitedNatural represents the infinity value.
     */
    public IsInfinity: boolean;

    /**
     * Contains the known numeric value of this UnlimitedNatural. This is only a valid value if IsInfinity is false. 
     */
    public Value: number | string | null = null;

    constructor(value: number | string) {
        if (typeof value == 'string') {
            if (value === "*") this.IsInfinity = true;
            else {
                this.IsInfinity = false;
                this.Value = Number.parseInt(value);
            }
        } else { // value is a number
            this.IsInfinity = false;
            this.Value = value;
        }
    }

    public stringValue() {
        if (this.IsInfinity) return "*";
        return this.Value ? this.Value.toString() : null;
    }

    public equals(other: UnlimitedNatural) {
        return (other != null)
            && (other.IsInfinity == this.IsInfinity)
            && (other.Value === this.Value);
    }
}


/**
* VisibilityKind is an enumeration type that defines literals to determine the visibility of Elements
* in a model.
*/
export enum VisibilityKind
{
	/**
	* A Named Element with public visibility is visible to all elements that can access the contents of
	* the Namespace that owns it.
	*/
	public = 1,
	/**
	* A NamedElement with private visibility is only visible inside the Namespace that owns it.
	*/
	private = 2,
	/**
	* A NamedElement with protected visibility is visible to Elements that have a generalization
	* relationship to the Namespace that owns it.
	*/
	protected = 3,
	/**
	* A NamedElement with package visibility is visible to all Elements within the nearest enclosing
	* Package (given that other owning Elements have proper visibility). Outside the nearest enclosing
	* Package, a NamedElement marked as having package visibility is not visible. Only NamedElements that
	* are not owned by Packages can be marked as having package visibility.
	*/
	package = 4
}

/**
* An Element is a constituent of a model. As such, it has the capability of owning other Elements.
*/
export interface Element {
	/**
	* Gets the element type.
	*/
	readonly elementType: ElementType;
	/**
	* Indicates which stereotypes from the selected profile (or profiles) are applied to the element. The
	* selected profiles are the profiles that are applied to the containing package.
	*/
	appliedStereotypes: Stereotype[];
	/**
	* Gets the unique ID of the element.
	*/
	id: string;
	/**
	* The Comments owned by this Element.
	*/
	ownedComments: Comment[];
	/**
	* Gets the element that owns this element.
	*/
	readonly owner: Element | null;
	/**
	* Contains 0 or more tagged values for the element.
	*/
	taggedValues: TaggedValueSpecification[];
	/**
	* Gets the text contents of the first comment in the element's owned comments, or an empty string if
	* the element has no comments.
	* @returns {string} The body string of the first comment. If the element has no comments, an empty
	* string is returned.
	*/
	getFirstCommentBody(): string;
}

/**
* A NamedElement is an Element in a model that may have a name. The name may be given directly and/or
* via the use of a StringExpression.
*/
export interface NamedElement extends Element {
	/**
	* The name of the NamedElement.
	*/
	name: string;
	/**
	* Determines whether and how the NamedElement is visible outside its owning Namespace.
	*/
	visibility: VisibilityKind | null;
}

/**
* A TypedElement is a NamedElement that may have a Type specified for it.
*/
export interface TypedElement extends NamedElement {
	/**
	* The type of the TypedElement.
	*/
	type: Type | null;
	/**
	* Gets the name of the typed element's type.
	* @returns {string} The type name, or an empty string if the element has no type.
	*/
	getTypeName(): string;
}

/**
* A ValueSpecification is the specification of a (possibly empty) set of values.
*/
export interface ValueSpecification extends TypedElement {
	/**
	* Gets the string representation of the value.
	* @returns {string}
	*/
	getStringValue(): string;
	/**
	* Gets underlying value of the ValueSpecification. The type depends on the type of ValueSpecification.
	* @returns {any} The underlying value of the ValueSpecification. The type depends on the type of
	* ValueSpecification.
	*/
	getValue(): any | null;
}

/**
* A PackageableElement is a NamedElement that may be owned directly by a Package.
*/
export interface PackageableElement extends NamedElement {
	/**
	* Gets the package that owns the packageable element. This property is derived.
	*/
	readonly package: Package;
	/**
	* Constructs a name from the names of the nesting packages. The name is constructed working inwards
	* from the package that is defined as namespace root up to but not including the PackageableElement
	* itself.
	* @param {string} separator The string to use to separate names. If not specified, a dot "." will be
	* used.
	* @returns {string} A single string with all the names separated.
	*/
	getNamespaceName(separator?: string): string;
	/**
	* Gets all packages that contain this Package, working inwards from the top Package to the owning
	* package.
	* @returns {Package[]} A collection of Packages.
	*/
	getNestingPackages(): Package[];
	/**
	* Constructs a name from the PackageableElement and the names of the nesting packages. The name is
	* constructed working inwards from the package that is defined as namespace root up to and including
	* the PackageableElement itself.
	* @param {string} separator The string to use to separate names. If not specified, a dot "." will be
	* used.
	* @returns {string} A single string with all the names separated.
	*/
	getQualifiedName(separator?: string): string;
}

/**
* A Type constrains the values represented by a TypedElement.
*/
export interface Type extends PackageableElement {
	/**
	* If true, the type was inferred by a tool, for example during data import. An inferred type is never
	* owned by any Package.
	*/
	isInferred: boolean;
}

/**
* Specifies the value of a meta attribute (tagged value) for a particular element.
*/
export interface TaggedValueSpecification {
	/**
	* Refers to the tagged value definition (metaattribute) of the tagged value's stereotype.
	*/
	definition: Property;
	/**
	* Specifies the actual tagged value.
	*/
	specification: ValueSpecification;
}

/**
* A RedefinableElement is an element that, when defined in the context of a Classifier, can be
* redefined more specifically or differently in the context of another Classifier that specializes
* (directly or indirectly) the context Classifier.
*/
export interface RedefinableElement extends NamedElement {
	/**
	* Indicates whether it is possible to further redefine a RedefinableElement. If the value is true,
	* then it is not possible to further redefine the RedefinableElement.
	*/
	isLeaf: boolean;
}

/**
* A Classifier represents a classification of instances according to their Features.
*/
export interface Classifier extends Type, RedefinableElement {
	/**
	* The Generalization relationships for this Classifier. These Generalizations navigate to more general
	* Classifiers in the generalization hierarchy.
	*/
	generalizations: Generalization[];
	/**
	* If true, the Classifier can only be instantiated by instantiating one of its specializations. An
	* abstract Classifier is intended to be used by other Classifiers e.g., as the target of Associations
	* or Generalizations.
	*/
	isAbstract: boolean;
	/**
	* If true, the Classifier cannot be specialized.
	*/
	isFinalSpecialization: boolean;
	/**
	* Returns all of the direct and indirect ancestors of a generalized Classifier, working outwards: more
	* specific classifiers will appear before more general classifiers.
	* @returns {Classifier[]}
	*/
	getAllParents(): Classifier[];
	/**
	* Gets all classifiers of which this element is a direct or indirect general.
	* @returns {Classifier[]}
	*/
	getAllSpecializations(): Classifier[];
	/**
	* Gets the first direct generalization relationship of the element.
	* @returns {Generalization}
	*/
	getFirstGeneralization(): Generalization | null;
	/**
	* Gets the first classifier that is an immediate general of the current element.
	* @returns {Classifier}
	*/
	getFirstParent(): Classifier | null;
	/**
	* Gives all of the immediate ancestors of a generalized Classifier.
	* @returns {Classifier[]}
	*/
	getParents(): Classifier[];
	/**
	* Gets all classifiers of which this classifier is a direct general.
	* @returns {Classifier[]}
	*/
	getSpecializations(): Classifier[];
}

/**
* StructuredClassifiers may contain an internal structure of connected elements each of which plays a
* role in the overall Behavior modeled by the StructuredClassifier.
*/
export interface StructuredClassifier extends Classifier {
}

/**
* A multiplicity is a definition of an inclusive interval of non-negative integers beginning with a
* lower bound and ending with a (possibly infinite) upper bound. A MultiplicityElement embeds this
* information to specify the allowable cardinalities for an instantiation of the Element.
*/
export interface MultiplicityElement extends Element {
	/**
	* For a multivalued multiplicity, this attribute specifies whether the values in an instantiation of
	* this MultiplicityElement are sequentially ordered.
	*/
	isOrdered: boolean;
	/**
	* For a multivalued multiplicity, this attributes specifies whether the values in an instantiation of
	* this MultiplicityElement are unique.
	*/
	isUnique: boolean;
	/**
	* Gets the lower bound of the multiplicity interval.
	*/
	readonly lower: number | null;
	/**
	* The specification of the lower bound for this multiplicity.
	*/
	lowerValue: ValueSpecification | null;
	/**
	* The upper bound of the multiplicity interval.
	*/
	readonly upper: UnlimitedNatural | null;
	/**
	* The specification of the upper bound for this multiplicity.
	*/
	upperValue: ValueSpecification | null;
	/**
	* The query lowerBound() returns the lower bound of the multiplicity as an integer, which is the
	* integerValue of lowerValue, if this is given, and 1 otherwise.
	* @returns {number}
	*/
	getLowerBound(): number;
	/**
	* The query upperBound() returns the upper bound of the multiplicity for a bounded multiplicity as an
	* unlimited natural, which is the unlimitedNaturalValue of upperValue, if given, and 1, otherwise.
	* @returns {UnlimitedNatural}
	*/
	getUpperBound(): UnlimitedNatural;
	/**
	* The query isMultivalued() checks whether this multiplicity has an upper bound greater than one.
	* @returns {boolean}
	*/
	isMultivalued(): boolean;
	/**
	* The query isOptional checks whether this multiplicity has a lower bound of 0 (0..n).
	* @returns {boolean}
	*/
	isOptional(): boolean;
	/**
	* The query isOptionalAndSingleValued checks whether this multiplicity has a lower bound of 0 and an
	* upper bound of 1 (0..1).
	* @returns {boolean}
	*/
	isOptionalAndSinglevalued(): boolean;
	/**
	* The query isRequiredAndSinglevalued checks whether this multiplicity has a lower bound of 1 and an
	* upper bound of 1 (1..1).
	* @returns {boolean}
	*/
	isRequiredAndSinglevalued(): boolean;
}

/**
* Defines a common interface for named elements that are part of an ordered collection.
*/
export interface OrderedElement extends Element {
	/**
	* Gets or set the sort order of the element if it is part of a collection. The value is 0 for elements
	* to which no particular ordering applies. Elements with a lower order come before elements with a
	* higher order.
	*/
	order: number;
}

/**
* A Feature declares a behavioral or structural characteristic of Classifiers.
*/
export interface Feature extends RedefinableElement, OrderedElement {
	/**
	* Specifies whether this Feature characterizes individual instances classified by the Classifier
	* (false) or the Classifier itself (true).
	*/
	isStatic: boolean;
}

/**
* A StructuralFeature is a typed feature of a Classifier that specifies the structure of instances of
* the Classifier.
*/
export interface StructuralFeature extends Feature, MultiplicityElement, TypedElement {
	/**
	* If isReadOnly is true, the StructuralFeature may not be written to after initialization.
	*/
	isReadOnly: boolean;
}

/**
* Each stereotype may extend one or more metaclasses through a StereoTypeExtension.
*/
export interface StereotypeExtension {
	/**
	* A required extension means that an instance of a stereotype must always be linked to an instance of
	* the extended metaclass. The instance of the stereotype is typically deleted only when either the
	* instance of the extended metaclass is deleted, or when the profile defining the stereotype is
	* removed from the applied profiles of the package.  
	*/
	isRequired: boolean;
	metaClass: ElementType;
}

/**
* Defines a common interface for Classifiers (Class, DataType and Interface) that have attributes and
* operations.
*/
export interface MemberedClassifier extends Classifier {
	/**
	* The attributes owned by the Element. Note that in UML, OwnedAttributes is a property of derived
	* classes of Classifier (Class, DataType and Interface).
	*/
	ownedAttributes: Property[];
	/**
	* The Operations owned by the Element. Note that in UML, OwnedOperations is a property of derived
	* classes of Classifier (Class, DataType and Interface).
	*/
	ownedOperations: Operation[];
	/**
	* Returns both inherited and owned attributes.
	* @returns {Property[]}
	*/
	getAllAttributes(): Property[];
	/**
	* Returns both inherited and owned operations. Any inherited operation that has the same signature
	* (having the same name and parameter type order) in an inheriting type is not included.
	* @returns {Operation[]}
	*/
	getAllOperations(): Operation[];
}

/**
* A BehavioredClassifier may have InterfaceRealizations, and owns a set of Behaviors one of which may
* specify the behavior of the BehavioredClassifier itself.
*/
export interface BehavioredClassifier extends Classifier {
	/**
	* The set of InterfaceRealizations owned by the BehavioredClassifier. Interface realizations reference
	* the Interfaces of which the BehavioredClassifier is an implementation.
	*/
	interfaceRealizations: InterfaceRealization[];
}

/**
* A Class classifies a set of objects and specifies the features that characterize the structure and
* behavior of those objects. A Class may have an internal structure and Ports.
*/
export interface Class extends BehavioredClassifier, StructuredClassifier, MemberedClassifier {
	/**
	* Determines whether an object specified by this Class is active or not. If true, then the owning
	* Class is referred to as an active Class. If false, then such a Class is referred to as a passive
	* Class.
	*/
	isActive: boolean;
	/**
	* Gets the superclasses of a Class, derived from its Generalizations.
	* @returns {Class[]}
	*/
	getSuperClasses(): Class[];
}

/**
* Stereotype is a profile class which defines how an existing metaclass may be extended as part of a
* profile. It enables the use of a platform or domain specific terminology or notation in place of, or
* in addition to, the ones used for the extended metaclass.
*/
export interface Stereotype extends Class {
	extends: StereotypeExtension[];
	/**
	* Gets a name for the stereotype that is safe to use in Javascript.
	*/
	safeName: string;
}

/**
* Relationship is an abstract concept that specifies some kind of relationship between Elements.
*/
export interface Relationship extends Element {
}

/**
* A Property is a StructuralFeature. A Property related by ownedAttribute to a Classifier (other than
* an association) represents an attribute and might also represent an association end. It relates an
* instance of the Classifier to a value or set of values of the type of the attribute. A Property
* related by memberEnd to an Association represents an end of the Association. The type of the
* Property is the type of the end of the Association.
*/
export interface Property extends StructuralFeature {
	aggregation: AggregationKind;
	/**
	* The Association of which this Property is a member, if any.
	*/
	readonly association: Association | null;
	/**
	* A ValueSpecification that is evaluated to give a default value for the Property when an instance of
	* the owning Classifier is instantiated.
	*/
	defaultValue: ValueSpecification | null;
	/**
	* Specifies whether the property is derived as the union of all of the Properties that are constrained
	* to subset it.
	*/
	isDerived: boolean;
	/**
	* Specifies whether the property is derived as the union of all of the Properties that are constrained
	* to subset it.
	*/
	isDerivedUnion: boolean;
	/**
	* True indicates this property can be used to uniquely identify an instance of the containing Class.
	*/
	isID: boolean;
	/**
	* Returns true if the Property is owned by a classifier or is included in the NavigableOwnedEnds of an
	* association.
	*/
	isNavigable: boolean;
	/**
	* Gets the value of the DefaultValue property.
	* @returns {any} The default value (the type depending on the type of value), or null if no default
	* value can be determined.
	*/
	getDefault(): any | null;
}

/**
* A package is used to group elements, and provides a namespace for the grouped elements.
* A package can have one or more profile applications to indicate which profiles have been applied.
* Because a profile is a package, it is possible to apply a profile not only to packages, but also to
* profiles.
*/
export interface Package extends PackageableElement {
	appliedProfiles: Profile[];
	/**
	* Denotes where the namespace structure for your class model starts; all nested packages below a
	* namespace root will form the namespace hierarchy for contained types.
	*/
	isNamespaceRoot: boolean;
	/**
	* Specifies the packageable elements that are owned by this Package.
	*/
	packagedElements: PackageableElement[];
	/**
	* Gets all classes that are owned by this Package, including the ones owned by nested packages.
	* @returns {Class[]}
	*/
	getAllClasses(): Class[];
	/**
	* Gets all data types that are owned by this Package, including the ones owned by nested packages.
	* @returns {DataType[]}
	*/
	getAllDataTypes(): DataType[];
	/**
	* Gets all enumerations that are owned by this Package, including the ones owned by nested packages.
	* @returns {Enumeration[]}
	*/
	getAllEnumerations(): Enumeration[];
	/**
	* Gets all interfaces that are owned by this Package, including the ones owned by nested packages.
	* @returns {Interface[]}
	*/
	getAllInterfaces(): Interface[];
	/**
	* Gets all types that are owned by this Package, including the ones owned by nested packages. This
	* includes the following types of elements: Class, Interface, DataType, PrimitiveType and Enumeration.
	* @returns {Classifier[]} A subset of PackagedElements.
	*/
	getAllTypes(): Classifier[];
	/**
	* Gets all classes that are owned by this Package.
	* @returns {Class[]} A subset of PackagedElements.
	*/
	getClasses(): Class[];
	/**
	* Gets all data types that are owned by this Package.
	* @returns {DataType[]} A subset of PackagedElements.
	*/
	getDataTypes(): DataType[];
	/**
	* Gets all enumerations that are owned by this Package.
	* @returns {Enumeration[]} A subset of PackagedElements.
	*/
	getEnumerations(): Enumeration[];
	/**
	* Gets all interfaces that are owned by this Package.
	* @returns {Interface[]} A subset of PackagedElements.
	*/
	getInterfaces(): Interface[];
	/**
	* Gets all packages that are owned by this Package.
	* @returns {Package[]} A subset of PackagedElements.
	*/
	getNestedPackages(): Package[];
	/**
	* Gets all types that are owned by this Package. This includes the following types of elements: Class,
	* Interface, DataType, PrimitiveType and Enumeration.
	* @returns {Classifier[]} A subset of PackagedElements.
	*/
	getTypes(): Classifier[];
}

/**
* Metamodel customizations are defined in a profile, which is then applied to a package. A profile can
* define classes, stereotypes, data types, primitive types, enumerations. Stereotypes are specific
* metaclasses, tagged values are standard metaattributes, and profiles are specific kinds of packages.
*/
export interface Profile extends Package {
	/**
	* Gets a name for the profile that is safe to use in Javascript.
	*/
	safeName: string;
}

/**
* A DataType is similar to a Class; however, instances of data type are identified only by their
* value. If two data types have the same value, the instances are considered identical.
*/
export interface DataType extends MemberedClassifier {
}

/**
* A PrimitiveType defines a predefined DataType, without any substructure. A PrimitiveType may have an
* algebra and operations defined outside of UML, for example, mathematically.
*/
export interface PrimitiveType extends DataType {
}

/**
* ParameterDirectionKind is an Enumeration that defines literals used to specify direction of
* parameters.
*/
export enum ParameterDirectionKind
{
	/**
	* Indicates that Parameter values are passed in by the caller.
	*/
	in = 1,
	/**
	* Indicates that Parameter values are passed in by the caller and (possibly different) values passed
	* out to the caller.
	*/
	inout = 2,
	/**
	* Indicates that Parameter values are passed out to the caller.
	*/
	out = 3,
	/**
	* Indicates that Parameter values are passed as return values back to the caller.
	*/
	return = 4
}

/**
* A Parameter is a specification of an argument used to pass information into or out of an invocation
* of a BehavioralFeature. Parameters can be treated as ConnectableElements within Collaborations.
*/
export interface Parameter extends TypedElement, MultiplicityElement, OrderedElement {
	/**
	* Specifies a ValueSpecification that represents a value to be used when no argument is supplied for
	* the Parameter.
	*/
	defaultValue: ValueSpecification | null;
	direction: ParameterDirectionKind;
	/**
	* Tells whether an output parameter may emit a value to the exclusion of the other outputs.
	*/
	isException: boolean;
	/**
	* Tells whether an input parameter may accept values while its behavior is executing, or whether an
	* output parameter may post values while the behavior is executing.
	*/
	isStream: boolean;
	/**
	* Gets the value of the DefaultValue property.
	* @returns {any} The default value (the type depending on the type of value), or null if no default
	* value can be determined.
	*/
	getDefault(): any | null;
}

/**
* A BehavioralFeature is a feature of a Classifier that specifies an aspect of the behavior of its
* instances. A BehavioralFeature is implemented (realized) by a Behavior. A BehavioralFeature
* specifies that a Classifier will respond to a designated request by invoking its implementing
* method.
*/
export interface BehavioralFeature extends Feature {
	/**
	* If true, then the BehavioralFeature does not have an implementation, and one must be supplied by a
	* more specific Classifier. If false, the BehavioralFeature must have an implementation in the
	* Classifier or one must be inherited.
	*/
	isAbstract: boolean;
	/**
	* The parameters owned by this Operation.
	*/
	ownedParameters: Parameter[];
}

/**
* An Operation is a BehavioralFeature of a Classifier that specifies the name, type, parameters, and
* constraints for invoking an associated Behavior. An Operation may invoke both the execution of
* method behaviors as well as other behavioral responses.
*/
export interface Operation extends BehavioralFeature {
	/**
	* Specifies if the operation is a class constructor.
	*/
	isConstructor: boolean;
	/**
	* Specifies whether an execution of the BehavioralFeature leaves the state of the system unchanged
	* (isQuery=true) or whether side effects may occur (isQuery=false).
	*/
	isQuery: boolean;
	/**
	* Gets the lower bound of the return parameter, if present. This information is derived from the
	* return result for this Operation.
	*/
	readonly lower: number | null;
	/**
	* The upper bound of the return parameter, if present. This information is derived
	* from the return result for this Operation.
	*/
	readonly upper: UnlimitedNatural | null;
	/**
	* Returns the ownedParameters with direction in and inout.
	* @returns {Parameter[]}
	*/
	getInputParameters(): Parameter[];
	/**
	* The query lowerBound() returns the lower bound of the return parameter as an integer, which is the
	* integerValue of lowerValue, if this is given, and 1 otherwise. This information is derived from the
	* return result for this Operation.
	* @returns {number}
	*/
	getLowerBound(): number;
	/**
	* Returns the ownedParameters with direction out, inout, or return.
	* @returns {Parameter[]}
	*/
	getOutputParameters(): Parameter[];
	/**
	* Gets the operation's return parameter, if it has one.
	* @returns {Parameter}
	*/
	getReturnParameter(): Parameter | null;
	/**
	* Gets the type of the operation's return parameter, if it has any.
	* @returns {Type}
	*/
	getReturnType(): Type | null;
	/**
	* The query upperBound() returns the upper bound of the return parameter for a bounded multiplicity as
	* an unlimited natural, which is the unlimitedNaturalValue of upperValue, if given, and 1, otherwise.
	* This information is derived from the return result for this Operation.
	* @returns {UnlimitedNatural}
	*/
	getUpperBound(): UnlimitedNatural;
	/**
	* The query isMultivalued() checks whether the return parameter has an upper bound greater than one.
	* @returns {boolean}
	*/
	isMultivalued(): boolean;
	/**
	* The query isOptional checks whether he return parameter has a lower bound of 0 (0..n).
	* @returns {boolean}
	*/
	isOptional(): boolean;
	/**
	* The query isOptional checks whether he return parameter has a lower bound of 0 and an upper bound of
	* 1 (0..1).
	* @returns {boolean}
	*/
	isOptionalAndSinglevalued(): boolean;
}

/**
* Represents the top-level package.
*/
export interface Model extends Package {
}

/**
* A LiteralSpecification identifies a literal constant being modeled.
*/
export interface LiteralSpecification extends ValueSpecification {
}

/**
* A LiteralUnlimitedNatural is a specification of an UnlimitedNatural number.
*/
export interface LiteralUnlimitedNatural extends LiteralSpecification {
	/**
	* The specified UnlimitedNatural value.
	*/
	value: UnlimitedNatural;
}

/**
* A LiteralString is a specification of a String value.
*/
export interface LiteralString extends LiteralSpecification {
	/**
	* The specified String value.
	*/
	value: string;
}

/**
* A LiteralReal is a specification of a Real value.
*/
export interface LiteralReal extends LiteralSpecification {
	/**
	* The specified Real value.
	*/
	value: number;
}

/**
* A LiteralNull specifies the lack of a value.
*/
export interface LiteralNull extends LiteralSpecification {
}

/**
* A LiteralInteger is a specification of an Integer value.
*/
export interface LiteralInteger extends LiteralSpecification {
	/**
	* The specified Integer value.
	*/
	value: number;
}

/**
* A LiteralBoolean is a specification of a Boolean value.
*/
export interface LiteralBoolean extends LiteralSpecification {
	/**
	* The specified Boolean value.
	*/
	value: boolean;
}

/**
* A DirectedRelationship represents a relationship between a collection of source model Elements and a
* collection of target model Elements.
*/
export interface DirectedRelationship extends Relationship {
}

/**
* An InterfaceRealization is a specialized realization relationship between a BehavioredClassifier and
* an Interface. This relationship signifies that the realizing BehavioredClassifier conforms to the
* contract specified by the Interface.
*/
export interface InterfaceRealization extends DirectedRelationship {
	/**
	* References the Interface specifying the conformance contract.
	*/
	contract: Interface;
}

/**
* Interfaces declare coherent services that are implemented by BehavioredClassifiers that implement
* the Interfaces via InterfaceRealizations.
*/
export interface Interface extends MemberedClassifier {
}

/**
* A Generalization is a taxonomic relationship between a more general Classifier and a more specific
* Classifier. Each instance of the specific Classifier is also an instance of the general
* Classifier.The specific Classifier inherits the features of the more general Classifier. A
* Generalization is owned by the specific Classifier.
*/
export interface Generalization extends DirectedRelationship {
	/**
	* The general classifier in the Generalization relationship.
	*/
	general: Classifier;
	/**
	* Indicates whether the specific Classifier can be used wherever the general Classifier can be used.
	* If true, the execution traces of the specific Classifier shall be a superset of the execution traces
	* of the general Classifier. If false, there is no such constraint on execution traces. If unset, the
	* modeler has not stated whether there is such a constraint or not.
	*/
	isSubstitutable: boolean;
	/**
	* Gets the specializing Classifier in the Generalization relationship. This property is derived.
	*/
	readonly specific: Classifier;
}

/**
* An EnumerationLiteral is a user-defined data value for an Enumeration.
*/
export interface EnumerationLiteral extends NamedElement, OrderedElement {
	/**
	* Gets the enumeration that owns this enumeration literal. This property is derived.
	*/
	readonly enumeration: Enumeration;
	specification: ValueSpecification;
	/**
	* Gets the value of the Specification property.
	* @returns {any} The default value (the type depending on the type of value), or null if no default
	* value can be determined.
	*/
	getSpecificationValue(): any | null;
}

/**
* An Enumeration is a DataType whose values are enumerated in the model as EnumerationLiterals.
*/
export interface Enumeration extends DataType {
	/**
	* Gets the base type of the enumeration. For most programming language, this is an integral type if
	* not specified.
	*/
	baseType: Type | null;
	/**
	* The ordered set of literals owned by this Enumeration.
	*/
	ownedLiterals: EnumerationLiteral[];
}

export interface DocumentReference {
	location: DocumentLocationKind;
	/**
	* Gets the name of the reference. If the reference is a NPM reference, this field contains the package
	* name (including any @scope). If the reference is a local one, this field contains the file name
	* without extension.
	*/
	name: string;
	path: string;
}

export enum DocumentLocationKind
{
	local = 1,
	npm = 2
}

export interface Document {
	creator: string;
	/**
	* Gets the unique ID of the document.
	*/
	id: string;
	/**
	* Contains the main model structure.
	*/
	model: Model | null;
	modelTypeName: string;
	modelTypeVersion: string;
	/**
	* Contains a model with 0 or more profiles (packages) in it.
	*/
	profiles: Model | null;
	references: DocumentReference[];
	/**
	* Returns an Element representing the element whose id property matches the specified string.
	* @returns {Element} The model element matching the specified ID, or null if no matching element was
	* found in the model.
	* @param {string} id The ID of the element to search for.
	*/
	findElementById(id: string): Element | null;
}

/**
* A Comment is a textual annotation that can be attached to a set of Elements.
*/
export interface Comment extends Element {
	body: string;
}

/**
* Associations represent relationships between classes.
*/
export interface Association extends Relationship, Classifier {
	/**
	* Gets all ends of the association, that is, ends that are either owned by the association or by a
	* classifier (as attributes).
	*/
	memberEnds: Property[];
	/**
	* The ends that are owned by the Association itself.
	*/
	ownedEnds: Property[];
}

/**
* AggregationKind is an Enumeration for specifying the kind of aggregation of a Property.
*/
export enum AggregationKind
{
	/**
	* Indicates that the Property has no aggregation.
	*/
	none = 1,
	/**
	* Indicates that the Property has shared aggregation.
	*/
	shared = 2,
	/**
	* Indicates that the Property is aggregated compositely, i.e., the composite object has responsibility
	* for the existence and storage of the composed objects (parts).
	*/
	composite = 3
}
