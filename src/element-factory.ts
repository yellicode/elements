/*
* Copyright (c) 2020 Yellicode
*
* This Source Code Form is subject to the terms of the Mozilla Public
* License, v. 2.0. If a copy of the MPL was not distributed with this
* file, You can obtain one at http://mozilla.org/MPL/2.0/.
*/

/**
* This code was generated by a tool.
* 
* Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
*/
import * as elements from './interfaces';
import * as classes from './classes';
import { ModelDelegate } from './model-delegate-interface';

export interface FactoryClassMap {
	'class': classes.Class;
	'stereotype': classes.Stereotype;
	'property': classes.Property;
	'package': classes.Package;
	'profile': classes.Profile;
	'dataType': classes.DataType;
	'primitiveType': classes.PrimitiveType;
	'parameter': classes.Parameter;
	'operation': classes.Operation;
	'model': classes.Model;
	'literalUnlimitedNatural': classes.LiteralUnlimitedNatural;
	'literalString': classes.LiteralString;
	'literalReal': classes.LiteralReal;
	'literalNull': classes.LiteralNull;
	'literalInteger': classes.LiteralInteger;
	'literalBoolean': classes.LiteralBoolean;
	'interfaceRealization': classes.InterfaceRealization;
	'interface': classes.Interface;
	'generalization': classes.Generalization;
	'enumerationLiteral': classes.EnumerationLiteral;
	'enumeration': classes.Enumeration;
	'comment': classes.Comment;
	'association': classes.Association;
}

export type createdElement<T extends keyof FactoryClassMap> = FactoryClassMap[T];

export class ElementFactory {
	constructor(private modelDelegate: ModelDelegate) {
	}

	public create<T extends keyof FactoryClassMap>(elementType: T, owner: elements.Element | null): createdElement<T> {
		switch (elementType)
		{
			case 'class':
				return new classes.Class(this.modelDelegate, owner) as FactoryClassMap[T];
			case 'stereotype':
				return new classes.Stereotype(this.modelDelegate, owner) as FactoryClassMap[T];
			case 'property':
				return new classes.Property(this.modelDelegate, owner) as FactoryClassMap[T];
			case 'package':
				return new classes.Package(this.modelDelegate, owner) as FactoryClassMap[T];
			case 'profile':
				return new classes.Profile(this.modelDelegate, owner) as FactoryClassMap[T];
			case 'dataType':
				return new classes.DataType(this.modelDelegate, owner) as FactoryClassMap[T];
			case 'primitiveType':
				return new classes.PrimitiveType(this.modelDelegate, owner) as FactoryClassMap[T];
			case 'parameter':
				return new classes.Parameter(this.modelDelegate, owner) as FactoryClassMap[T];
			case 'operation':
				return new classes.Operation(this.modelDelegate, owner) as FactoryClassMap[T];
			case 'model':
				return new classes.Model(this.modelDelegate, owner) as FactoryClassMap[T];
			case 'literalUnlimitedNatural':
				return new classes.LiteralUnlimitedNatural(this.modelDelegate, owner) as FactoryClassMap[T];
			case 'literalString':
				return new classes.LiteralString(this.modelDelegate, owner) as FactoryClassMap[T];
			case 'literalReal':
				return new classes.LiteralReal(this.modelDelegate, owner) as FactoryClassMap[T];
			case 'literalNull':
				return new classes.LiteralNull(this.modelDelegate, owner) as FactoryClassMap[T];
			case 'literalInteger':
				return new classes.LiteralInteger(this.modelDelegate, owner) as FactoryClassMap[T];
			case 'literalBoolean':
				return new classes.LiteralBoolean(this.modelDelegate, owner) as FactoryClassMap[T];
			case 'interfaceRealization':
				return new classes.InterfaceRealization(this.modelDelegate, owner) as FactoryClassMap[T];
			case 'interface':
				return new classes.Interface(this.modelDelegate, owner) as FactoryClassMap[T];
			case 'generalization':
				return new classes.Generalization(this.modelDelegate, owner) as FactoryClassMap[T];
			case 'enumerationLiteral':
				return new classes.EnumerationLiteral(this.modelDelegate, owner) as FactoryClassMap[T];
			case 'enumeration':
				return new classes.Enumeration(this.modelDelegate, owner) as FactoryClassMap[T];
			case 'comment':
				return new classes.Comment(this.modelDelegate, owner) as FactoryClassMap[T];
			case 'association':
				return new classes.Association(this.modelDelegate, owner) as FactoryClassMap[T];
			default:
				throw `Cannot create element of type ${elementType}. The element type is not supported.`;
		}
	}

	public static requiresId<T extends keyof FactoryClassMap>(elementType: T): boolean {
		switch (elementType)
		{
			case 'literalUnlimitedNatural':
			case 'literalString':
			case 'literalReal':
			case 'literalNull':
			case 'literalInteger':
			case 'literalBoolean':
			case 'enumerationLiteral':
			case 'comment':
				return false;
			default:
				return true;
		}
	}
}
