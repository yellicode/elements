/*
* Copyright (c) 2020 Yellicode
*
* This Source Code Form is subject to the terms of the Mozilla Public
* License, v. 2.0. If a copy of the MPL was not distributed with this
* file, You can obtain one at http://mozilla.org/MPL/2.0/.
*/

/**
* This code was generated by a tool.
* 
* Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
*/
import * as elements from './interfaces';
import * as editable from './editable-interfaces';
import { ModelDelegate } from './model-delegate-interface';

export abstract class Element implements elements.Element {
	constructor(protected modelDelegate:ModelDelegate, owner: elements.Element | null)
	{
		this.owner = owner;
	}

	public abstract readonly elementType: elements.ElementType;

	public appliedStereotypes: elements.Stereotype[] = [];

	public id: string = '';

	public ownedComments: elements.Comment[] = [];

	public readonly owner: elements.Element | null = null;

	public taggedValues: elements.TaggedValueSpecification[] = [];

	/**
	* Gets the text contents of the first comment in the element's owned comments, or an empty string if
	* the element has no comments.
	* @returns {string} The body string of the first comment. If the element has no comments, an empty
	* string is returned.
	*/
	public getFirstCommentBody(): string
	{
		return this.modelDelegate.getFirstCommentBody(this);
	}
}

export class TaggedValueSpecification implements elements.TaggedValueSpecification {

	public definition!: elements.Property;

	public specification!: elements.ValueSpecification;
}

export class StereotypeExtension implements elements.StereotypeExtension {

	public isRequired: boolean = false;

	public metaClass!: elements.ElementType;
}

export class Class extends Element implements elements.Class, editable.ClassEditable {
	constructor(modelDelegate:ModelDelegate, owner: elements.Element | null) {super(modelDelegate, owner);}

	public readonly elementType:elements.ElementType = elements.ElementType.class;

	public appliedStereotypes: elements.Stereotype[] = [];

	public generalizations: elements.Generalization[] = [];

	public interfaceRealizations: elements.InterfaceRealization[] = [];

	public isAbstract: boolean = false;

	public isActive: boolean = false;

	public isDeprecated: boolean = false;

	public isFinalSpecialization: boolean = false;

	public isInferred: boolean = false;

	public isLeaf: boolean = false;

	public name: string = '';

	public ownedAttributes: elements.Property[] = [];

	public ownedOperations: elements.Operation[] = [];

	public get package(): elements.Package {
		return this.modelDelegate.getPackage(this);
	}

	public taggedValues: elements.TaggedValueSpecification[] = [];

	public visibility: elements.VisibilityKind | null = null;

	/**
	* Returns both inherited and owned attributes.
	* @returns {elements.Property[]}
	*/
	public getAllAttributes(): elements.Property[]
	{
		return this.modelDelegate.getAllAttributes(this);
	}

	/**
	* Returns both inherited and owned operations. Any inherited operation that has the same signature
	* (having the same name and parameter type order) in an inheriting type is not included.
	* @returns {elements.Operation[]}
	*/
	public getAllOperations(): elements.Operation[]
	{
		return this.modelDelegate.getAllOperations(this);
	}

	/**
	* Returns all of the direct and indirect ancestors of a generalized Classifier, working outwards: more
	* specific classifiers will appear before more general classifiers.
	* @returns {elements.Classifier[]}
	*/
	public getAllParents(): elements.Classifier[]
	{
		return this.modelDelegate.getAllParents(this);
	}

	/**
	* Gets all classifiers of which this element is a direct or indirect general.
	* @returns {elements.Classifier[]}
	*/
	public getAllSpecializations(): elements.Classifier[]
	{
		return this.modelDelegate.getAllSpecializations(this);
	}

	/**
	* Gets the first direct generalization relationship of the element.
	* @returns {elements.Generalization}
	*/
	public getFirstGeneralization(): elements.Generalization | null
	{
		return this.modelDelegate.getFirstGeneralization(this);
	}

	/**
	* Gets the first classifier that is an immediate general of the current element.
	* @returns {elements.Classifier}
	*/
	public getFirstParent(): elements.Classifier | null
	{
		return this.modelDelegate.getFirstParent(this);
	}

	/**
	* Constructs a name from the names of the nesting packages. The name is constructed working inwards
	* from the package that is defined as namespace root up to but not including the PackageableElement
	* itself.
	* @param {string} separator The string to use to separate names. If not specified, a dot "." will be
	* used.
	* @returns {string} A single string with all the names separated.
	*/
	public getNamespaceName(separator?: string): string
	{
		return this.modelDelegate.getNamespaceName(this, separator);
	}

	/**
	* Gets all packages that contain this Package, working inwards from the top Package to the owning
	* package.
	* @returns {elements.Package[]} A collection of Packages.
	*/
	public getNestingPackages(): elements.Package[]
	{
		return this.modelDelegate.getNestingPackages(this);
	}

	/**
	* Gives all of the immediate ancestors of a generalized Classifier.
	* @returns {elements.Classifier[]}
	*/
	public getParents(): elements.Classifier[]
	{
		return this.modelDelegate.getParents(this);
	}

	/**
	* Constructs a name from the PackageableElement and the names of the nesting packages. The name is
	* constructed working inwards from the package that is defined as namespace root up to and including
	* the PackageableElement itself.
	* @param {string} separator The string to use to separate names. If not specified, a dot "." will be
	* used.
	* @returns {string} A single string with all the names separated.
	*/
	public getQualifiedName(separator?: string): string
	{
		return this.modelDelegate.getQualifiedName(this, separator);
	}

	/**
	* Gets all classifiers of which this classifier is a direct general.
	* @returns {elements.Classifier[]}
	*/
	public getSpecializations(): elements.Classifier[]
	{
		return this.modelDelegate.getSpecializations(this);
	}

	/**
	* Gets the superclasses of a Class, derived from its Generalizations.
	* @returns {elements.Class[]}
	*/
	public getSuperClasses(): elements.Class[]
	{
		return this.modelDelegate.getSuperClasses(this);
	}

	public addAppliedStereotype(stereotype: elements.Stereotype): this
	{
		this.appliedStereotypes.push(stereotype);
		this.modelDelegate.onAppliedStereotypeAdded(this, stereotype);
		return this;
	}

	public addOwnedComment(properties: editable.CommentProperties): this
	{
		this.ownedComments.push(this.modelDelegate.createElement('comment', this, properties, null));
		return this;
	}

	public addGeneralization(properties: editable.GeneralizationProperties, initFn?: (generalization: editable.GeneralizationEditable) => void): this
	{
		this.generalizations.push(this.modelDelegate.createElement('generalization', this, properties, initFn || null));
		return this;
	}

	public addInterfaceRealization(properties: editable.InterfaceRealizationProperties, initFn?: (interfaceRealization: editable.InterfaceRealizationEditable) => void): this
	{
		this.interfaceRealizations.push(this.modelDelegate.createElement('interfaceRealization', this, properties, initFn || null));
		return this;
	}

	public addOwnedAttribute(properties: editable.PropertyProperties, initFn?: (property: editable.PropertyEditable) => void): this
	{
		this.ownedAttributes.push(this.modelDelegate.createElement('property', this, properties, initFn || null));
		return this;
	}

	public addOwnedOperation(properties: editable.OperationProperties, initFn?: (operation: editable.OperationEditable) => void): this
	{
		this.ownedOperations.push(this.modelDelegate.createElement('operation', this, properties, initFn || null));
		return this;
	}
}

export class Stereotype extends Element implements elements.Stereotype, editable.StereotypeEditable {
	constructor(modelDelegate:ModelDelegate, owner: elements.Element | null) {super(modelDelegate, owner);}

	public readonly elementType:elements.ElementType = elements.ElementType.stereotype;

	public appliedStereotypes: elements.Stereotype[] = [];

	public extends: elements.StereotypeExtension[] = [];

	public generalizations: elements.Generalization[] = [];

	public interfaceRealizations: elements.InterfaceRealization[] = [];

	public isAbstract: boolean = false;

	public isActive: boolean = false;

	public isDeprecated: boolean = false;

	public isFinalSpecialization: boolean = false;

	public isInferred: boolean = false;

	public isLeaf: boolean = false;

	public name: string = '';

	public ownedAttributes: elements.Property[] = [];

	public ownedOperations: elements.Operation[] = [];

	public get package(): elements.Package {
		return this.modelDelegate.getPackage(this);
	}

	public safeName: string = '';

	public taggedValues: elements.TaggedValueSpecification[] = [];

	public visibility: elements.VisibilityKind | null = null;

	/**
	* Returns both inherited and owned attributes.
	* @returns {elements.Property[]}
	*/
	public getAllAttributes(): elements.Property[]
	{
		return this.modelDelegate.getAllAttributes(this);
	}

	/**
	* Returns both inherited and owned operations. Any inherited operation that has the same signature
	* (having the same name and parameter type order) in an inheriting type is not included.
	* @returns {elements.Operation[]}
	*/
	public getAllOperations(): elements.Operation[]
	{
		return this.modelDelegate.getAllOperations(this);
	}

	/**
	* Returns all of the direct and indirect ancestors of a generalized Classifier, working outwards: more
	* specific classifiers will appear before more general classifiers.
	* @returns {elements.Classifier[]}
	*/
	public getAllParents(): elements.Classifier[]
	{
		return this.modelDelegate.getAllParents(this);
	}

	/**
	* Gets all classifiers of which this element is a direct or indirect general.
	* @returns {elements.Classifier[]}
	*/
	public getAllSpecializations(): elements.Classifier[]
	{
		return this.modelDelegate.getAllSpecializations(this);
	}

	/**
	* Gets the first direct generalization relationship of the element.
	* @returns {elements.Generalization}
	*/
	public getFirstGeneralization(): elements.Generalization | null
	{
		return this.modelDelegate.getFirstGeneralization(this);
	}

	/**
	* Gets the first classifier that is an immediate general of the current element.
	* @returns {elements.Classifier}
	*/
	public getFirstParent(): elements.Classifier | null
	{
		return this.modelDelegate.getFirstParent(this);
	}

	/**
	* Constructs a name from the names of the nesting packages. The name is constructed working inwards
	* from the package that is defined as namespace root up to but not including the PackageableElement
	* itself.
	* @param {string} separator The string to use to separate names. If not specified, a dot "." will be
	* used.
	* @returns {string} A single string with all the names separated.
	*/
	public getNamespaceName(separator?: string): string
	{
		return this.modelDelegate.getNamespaceName(this, separator);
	}

	/**
	* Gets all packages that contain this Package, working inwards from the top Package to the owning
	* package.
	* @returns {elements.Package[]} A collection of Packages.
	*/
	public getNestingPackages(): elements.Package[]
	{
		return this.modelDelegate.getNestingPackages(this);
	}

	/**
	* Gives all of the immediate ancestors of a generalized Classifier.
	* @returns {elements.Classifier[]}
	*/
	public getParents(): elements.Classifier[]
	{
		return this.modelDelegate.getParents(this);
	}

	/**
	* Constructs a name from the PackageableElement and the names of the nesting packages. The name is
	* constructed working inwards from the package that is defined as namespace root up to and including
	* the PackageableElement itself.
	* @param {string} separator The string to use to separate names. If not specified, a dot "." will be
	* used.
	* @returns {string} A single string with all the names separated.
	*/
	public getQualifiedName(separator?: string): string
	{
		return this.modelDelegate.getQualifiedName(this, separator);
	}

	/**
	* Gets all classifiers of which this classifier is a direct general.
	* @returns {elements.Classifier[]}
	*/
	public getSpecializations(): elements.Classifier[]
	{
		return this.modelDelegate.getSpecializations(this);
	}

	/**
	* Gets the superclasses of a Class, derived from its Generalizations.
	* @returns {elements.Class[]}
	*/
	public getSuperClasses(): elements.Class[]
	{
		return this.modelDelegate.getSuperClasses(this);
	}

	public addAppliedStereotype(stereotype: elements.Stereotype): this
	{
		this.appliedStereotypes.push(stereotype);
		this.modelDelegate.onAppliedStereotypeAdded(this, stereotype);
		return this;
	}

	public addOwnedComment(properties: editable.CommentProperties): this
	{
		this.ownedComments.push(this.modelDelegate.createElement('comment', this, properties, null));
		return this;
	}

	public addGeneralization(properties: editable.GeneralizationProperties, initFn?: (generalization: editable.GeneralizationEditable) => void): this
	{
		this.generalizations.push(this.modelDelegate.createElement('generalization', this, properties, initFn || null));
		return this;
	}

	public addInterfaceRealization(properties: editable.InterfaceRealizationProperties, initFn?: (interfaceRealization: editable.InterfaceRealizationEditable) => void): this
	{
		this.interfaceRealizations.push(this.modelDelegate.createElement('interfaceRealization', this, properties, initFn || null));
		return this;
	}

	public addOwnedAttribute(properties: editable.PropertyProperties, initFn?: (property: editable.PropertyEditable) => void): this
	{
		this.ownedAttributes.push(this.modelDelegate.createElement('property', this, properties, initFn || null));
		return this;
	}

	public addOwnedOperation(properties: editable.OperationProperties, initFn?: (operation: editable.OperationEditable) => void): this
	{
		this.ownedOperations.push(this.modelDelegate.createElement('operation', this, properties, initFn || null));
		return this;
	}
}

export class Property extends Element implements elements.Property, editable.PropertyEditable {
	constructor(modelDelegate:ModelDelegate, owner: elements.Element | null) {super(modelDelegate, owner);}

	public readonly elementType:elements.ElementType = elements.ElementType.property;

	public aggregation: elements.AggregationKind = elements.AggregationKind.none;

	public appliedStereotypes: elements.Stereotype[] = [];

	public get association(): elements.Association | null {
		return this.modelDelegate.getAssociation(this);
	}

	public defaultValue: elements.ValueSpecification | null = null;

	public isDeprecated: boolean = false;

	public isDerived: boolean = false;

	public isDerivedUnion: boolean = false;

	public isID: boolean = false;

	public isLeaf: boolean = false;

	public isNavigable: boolean = false;

	public isOrdered: boolean = false;

	public isReadOnly: boolean = false;

	public isStatic: boolean = false;

	public isUnique: boolean = false;

	public get lower(): number | null {
		return this.modelDelegate.getLower(this);
	}

	public lowerValue: elements.ValueSpecification | null = null;

	public name: string = '';

	public order: number = 0;

	public taggedValues: elements.TaggedValueSpecification[] = [];

	public type: elements.Type | null = null;

	public get upper(): elements.UnlimitedNatural | null {
		return this.modelDelegate.getUpper(this);
	}

	public upperValue: elements.ValueSpecification | null = null;

	public visibility: elements.VisibilityKind | null = null;

	/**
	* Gets the value of the DefaultValue property.
	* @returns {any} The default value (the type depending on the type of value), or null if no default
	* value can be determined.
	*/
	public getDefault(): any | null
	{
		return this.modelDelegate.getDefault(this);
	}

	/**
	* The query lowerBound() returns the lower bound of the multiplicity as an integer, which is the
	* integerValue of lowerValue, if this is given, and 1 otherwise.
	* @returns {number}
	*/
	public getLowerBound(): number
	{
		return this.modelDelegate.getLowerBound(this);
	}

	/**
	* Gets the name of the typed element's type.
	* @returns {string} The type name, or an empty string if the element has no type.
	*/
	public getTypeName(): string
	{
		return this.modelDelegate.getTypeName(this);
	}

	/**
	* The query upperBound() returns the upper bound of the multiplicity for a bounded multiplicity as an
	* unlimited natural, which is the unlimitedNaturalValue of upperValue, if given, and 1, otherwise.
	* @returns {elements.UnlimitedNatural}
	*/
	public getUpperBound(): elements.UnlimitedNatural
	{
		return this.modelDelegate.getUpperBound(this);
	}

	/**
	* The query isMultivalued() checks whether this multiplicity has an upper bound greater than one.
	* @returns {boolean}
	*/
	public isMultivalued(): boolean
	{
		return this.modelDelegate.isMultivalued(this);
	}

	/**
	* The query isOptional checks whether this multiplicity has a lower bound of 0 (0..n).
	* @returns {boolean}
	*/
	public isOptional(): boolean
	{
		return this.modelDelegate.isOptional(this);
	}

	/**
	* The query isOptionalAndSingleValued checks whether this multiplicity has a lower bound of 0 and an
	* upper bound of 1 (0..1).
	* @returns {boolean}
	*/
	public isOptionalAndSinglevalued(): boolean
	{
		return this.modelDelegate.isOptionalAndSinglevalued(this);
	}

	/**
	* The query isRequiredAndSinglevalued checks whether this multiplicity has a lower bound of 1 and an
	* upper bound of 1 (1..1).
	* @returns {boolean}
	*/
	public isRequiredAndSinglevalued(): boolean
	{
		return this.modelDelegate.isRequiredAndSinglevalued(this);
	}

	public addAppliedStereotype(stereotype: elements.Stereotype): this
	{
		this.appliedStereotypes.push(stereotype);
		this.modelDelegate.onAppliedStereotypeAdded(this, stereotype);
		return this;
	}

	public addOwnedComment(properties: editable.CommentProperties): this
	{
		this.ownedComments.push(this.modelDelegate.createElement('comment', this, properties, null));
		return this;
	}

	public setLowerValueUnlimited(): this
	{
		this.modelDelegate.setLowerValueUnlimited(this);
		return this;
	}

	public setLowerValue(value: number): this
	{
		this.modelDelegate.setLowerValue(this, value);
		return this;
	}

	public setUpperValueUnlimited(): this
	{
		this.modelDelegate.setUpperValueUnlimited(this);
		return this;
	}

	public setUpperValue(value: number): this
	{
		this.modelDelegate.setUpperValue(this, value);
		return this;
	}

	public setDefaultValueNull(): this
	{
		this.modelDelegate.setDefaultValueNull(this);
		return this;
	}

	public setDefaultValue(value: boolean): this;
	public setDefaultValue(value: number): this;
	public setDefaultValue(value: string): this;
	public setDefaultValue(value: any): this
	{
		this.modelDelegate.setDefaultValue(this, value);
		return this;
	}
}

export class Package extends Element implements elements.Package, editable.PackageEditable {
	constructor(modelDelegate:ModelDelegate, owner: elements.Element | null) {super(modelDelegate, owner);}

	public readonly elementType:elements.ElementType = elements.ElementType.package;

	public appliedProfiles: elements.Profile[] = [];

	public appliedStereotypes: elements.Stereotype[] = [];

	public isDeprecated: boolean = false;

	public isNamespaceRoot: boolean = false;

	public name: string = '';

	public get package(): elements.Package {
		return this.modelDelegate.getPackage(this);
	}

	public packagedElements: elements.PackageableElement[] = [];

	public taggedValues: elements.TaggedValueSpecification[] = [];

	public visibility: elements.VisibilityKind | null = null;

	/**
	* Gets all classes that are owned by this Package, including the ones owned by nested packages.
	* @returns {elements.Class[]}
	*/
	public getAllClasses(): elements.Class[]
	{
		return this.modelDelegate.getAllClasses(this);
	}

	/**
	* Gets all data types that are owned by this Package, including the ones owned by nested packages.
	* @returns {elements.DataType[]}
	*/
	public getAllDataTypes(): elements.DataType[]
	{
		return this.modelDelegate.getAllDataTypes(this);
	}

	/**
	* Gets all enumerations that are owned by this Package, including the ones owned by nested packages.
	* @returns {elements.Enumeration[]}
	*/
	public getAllEnumerations(): elements.Enumeration[]
	{
		return this.modelDelegate.getAllEnumerations(this);
	}

	/**
	* Gets all interfaces that are owned by this Package, including the ones owned by nested packages.
	* @returns {elements.Interface[]}
	*/
	public getAllInterfaces(): elements.Interface[]
	{
		return this.modelDelegate.getAllInterfaces(this);
	}

	/**
	* Gets all types that are owned by this Package, including the ones owned by nested packages. This
	* includes the following types of elements: Class, Interface, DataType, PrimitiveType and Enumeration.
	* @returns {elements.Classifier[]} A subset of PackagedElements.
	*/
	public getAllTypes(): elements.Classifier[]
	{
		return this.modelDelegate.getAllTypes(this);
	}

	/**
	* Gets all classes that are owned by this Package.
	* @returns {elements.Class[]} A subset of PackagedElements.
	*/
	public getClasses(): elements.Class[]
	{
		return this.modelDelegate.getClasses(this);
	}

	/**
	* Gets all data types that are owned by this Package.
	* @returns {elements.DataType[]} A subset of PackagedElements.
	*/
	public getDataTypes(): elements.DataType[]
	{
		return this.modelDelegate.getDataTypes(this);
	}

	/**
	* Gets all enumerations that are owned by this Package.
	* @returns {elements.Enumeration[]} A subset of PackagedElements.
	*/
	public getEnumerations(): elements.Enumeration[]
	{
		return this.modelDelegate.getEnumerations(this);
	}

	/**
	* Gets all interfaces that are owned by this Package.
	* @returns {elements.Interface[]} A subset of PackagedElements.
	*/
	public getInterfaces(): elements.Interface[]
	{
		return this.modelDelegate.getInterfaces(this);
	}

	/**
	* Constructs a name from the names of the nesting packages. The name is constructed working inwards
	* from the package that is defined as namespace root up to but not including the PackageableElement
	* itself.
	* @param {string} separator The string to use to separate names. If not specified, a dot "." will be
	* used.
	* @returns {string} A single string with all the names separated.
	*/
	public getNamespaceName(separator?: string): string
	{
		return this.modelDelegate.getNamespaceName(this, separator);
	}

	/**
	* Gets all packages that are owned by this Package.
	* @returns {elements.Package[]} A subset of PackagedElements.
	*/
	public getNestedPackages(): elements.Package[]
	{
		return this.modelDelegate.getNestedPackages(this);
	}

	/**
	* Gets all packages that contain this Package, working inwards from the top Package to the owning
	* package.
	* @returns {elements.Package[]} A collection of Packages.
	*/
	public getNestingPackages(): elements.Package[]
	{
		return this.modelDelegate.getNestingPackages(this);
	}

	/**
	* Constructs a name from the PackageableElement and the names of the nesting packages. The name is
	* constructed working inwards from the package that is defined as namespace root up to and including
	* the PackageableElement itself.
	* @param {string} separator The string to use to separate names. If not specified, a dot "." will be
	* used.
	* @returns {string} A single string with all the names separated.
	*/
	public getQualifiedName(separator?: string): string
	{
		return this.modelDelegate.getQualifiedName(this, separator);
	}

	/**
	* Gets all types that are owned by this Package. This includes the following types of elements: Class,
	* Interface, DataType, PrimitiveType and Enumeration.
	* @returns {elements.Classifier[]} A subset of PackagedElements.
	*/
	public getTypes(): elements.Classifier[]
	{
		return this.modelDelegate.getTypes(this);
	}

	public addAppliedStereotype(stereotype: elements.Stereotype): this
	{
		this.appliedStereotypes.push(stereotype);
		this.modelDelegate.onAppliedStereotypeAdded(this, stereotype);
		return this;
	}

	public addOwnedComment(properties: editable.CommentProperties): this
	{
		this.ownedComments.push(this.modelDelegate.createElement('comment', this, properties, null));
		return this;
	}

	public addAppliedProfile(profile: elements.Profile): this
	{
		this.appliedProfiles.push(profile);
		this.modelDelegate.onAppliedProfileAdded(this, profile);
		return this;
	}

	public addPackage(properties: editable.PackageProperties, initFn?: (pack: editable.PackageEditable) => void): this
	{
		this.packagedElements.push(this.modelDelegate.createElement('package', this, properties, initFn || null));
		return this;
	}
	public addProfile(properties: editable.ProfileProperties, initFn?: (profile: editable.ProfileEditable) => void): this
	{
		this.packagedElements.push(this.modelDelegate.createElement('profile', this, properties, initFn || null));
		return this;
	}
	public addAssociation(properties: editable.AssociationProperties, initFn?: (association: editable.AssociationEditable) => void): this
	{
		this.packagedElements.push(this.modelDelegate.createElement('association', this, properties, initFn || null));
		return this;
	}
	public addClass(properties: editable.ClassProperties, initFn?: (cls: editable.ClassEditable) => void): this
	{
		this.packagedElements.push(this.modelDelegate.createElement('class', this, properties, initFn || null));
		return this;
	}
	public addStereotype(properties: editable.StereotypeProperties, initFn?: (stereotype: editable.StereotypeEditable) => void): this
	{
		this.packagedElements.push(this.modelDelegate.createElement('stereotype', this, properties, initFn || null));
		return this;
	}
	public addDataType(properties: editable.DataTypeProperties, initFn?: (dataType: editable.DataTypeEditable) => void): this
	{
		this.packagedElements.push(this.modelDelegate.createElement('dataType', this, properties, initFn || null));
		return this;
	}
	public addEnumeration(properties: editable.EnumerationProperties, initFn?: (enumeration: editable.EnumerationEditable) => void): this
	{
		this.packagedElements.push(this.modelDelegate.createElement('enumeration', this, properties, initFn || null));
		return this;
	}
	public addPrimitiveType(properties: editable.PrimitiveTypeProperties, initFn?: (primitiveType: editable.PrimitiveTypeEditable) => void): this
	{
		this.packagedElements.push(this.modelDelegate.createElement('primitiveType', this, properties, initFn || null));
		return this;
	}
	public addInterface(properties: editable.InterfaceProperties, initFn?: (iface: editable.InterfaceEditable) => void): this
	{
		this.packagedElements.push(this.modelDelegate.createElement('interface', this, properties, initFn || null));
		return this;
	}
}

export class Profile extends Element implements elements.Profile, editable.ProfileEditable {
	constructor(modelDelegate:ModelDelegate, owner: elements.Element | null) {super(modelDelegate, owner);}

	public readonly elementType:elements.ElementType = elements.ElementType.profile;

	public appliedProfiles: elements.Profile[] = [];

	public appliedStereotypes: elements.Stereotype[] = [];

	public isDeprecated: boolean = false;

	public isNamespaceRoot: boolean = false;

	public name: string = '';

	public get package(): elements.Package {
		return this.modelDelegate.getPackage(this);
	}

	public packagedElements: elements.PackageableElement[] = [];

	public safeName: string = '';

	public taggedValues: elements.TaggedValueSpecification[] = [];

	public visibility: elements.VisibilityKind | null = null;

	/**
	* Gets all classes that are owned by this Package, including the ones owned by nested packages.
	* @returns {elements.Class[]}
	*/
	public getAllClasses(): elements.Class[]
	{
		return this.modelDelegate.getAllClasses(this);
	}

	/**
	* Gets all data types that are owned by this Package, including the ones owned by nested packages.
	* @returns {elements.DataType[]}
	*/
	public getAllDataTypes(): elements.DataType[]
	{
		return this.modelDelegate.getAllDataTypes(this);
	}

	/**
	* Gets all enumerations that are owned by this Package, including the ones owned by nested packages.
	* @returns {elements.Enumeration[]}
	*/
	public getAllEnumerations(): elements.Enumeration[]
	{
		return this.modelDelegate.getAllEnumerations(this);
	}

	/**
	* Gets all interfaces that are owned by this Package, including the ones owned by nested packages.
	* @returns {elements.Interface[]}
	*/
	public getAllInterfaces(): elements.Interface[]
	{
		return this.modelDelegate.getAllInterfaces(this);
	}

	/**
	* Gets all types that are owned by this Package, including the ones owned by nested packages. This
	* includes the following types of elements: Class, Interface, DataType, PrimitiveType and Enumeration.
	* @returns {elements.Classifier[]} A subset of PackagedElements.
	*/
	public getAllTypes(): elements.Classifier[]
	{
		return this.modelDelegate.getAllTypes(this);
	}

	/**
	* Gets all classes that are owned by this Package.
	* @returns {elements.Class[]} A subset of PackagedElements.
	*/
	public getClasses(): elements.Class[]
	{
		return this.modelDelegate.getClasses(this);
	}

	/**
	* Gets all data types that are owned by this Package.
	* @returns {elements.DataType[]} A subset of PackagedElements.
	*/
	public getDataTypes(): elements.DataType[]
	{
		return this.modelDelegate.getDataTypes(this);
	}

	/**
	* Gets all enumerations that are owned by this Package.
	* @returns {elements.Enumeration[]} A subset of PackagedElements.
	*/
	public getEnumerations(): elements.Enumeration[]
	{
		return this.modelDelegate.getEnumerations(this);
	}

	/**
	* Gets all interfaces that are owned by this Package.
	* @returns {elements.Interface[]} A subset of PackagedElements.
	*/
	public getInterfaces(): elements.Interface[]
	{
		return this.modelDelegate.getInterfaces(this);
	}

	/**
	* Constructs a name from the names of the nesting packages. The name is constructed working inwards
	* from the package that is defined as namespace root up to but not including the PackageableElement
	* itself.
	* @param {string} separator The string to use to separate names. If not specified, a dot "." will be
	* used.
	* @returns {string} A single string with all the names separated.
	*/
	public getNamespaceName(separator?: string): string
	{
		return this.modelDelegate.getNamespaceName(this, separator);
	}

	/**
	* Gets all packages that are owned by this Package.
	* @returns {elements.Package[]} A subset of PackagedElements.
	*/
	public getNestedPackages(): elements.Package[]
	{
		return this.modelDelegate.getNestedPackages(this);
	}

	/**
	* Gets all packages that contain this Package, working inwards from the top Package to the owning
	* package.
	* @returns {elements.Package[]} A collection of Packages.
	*/
	public getNestingPackages(): elements.Package[]
	{
		return this.modelDelegate.getNestingPackages(this);
	}

	/**
	* Constructs a name from the PackageableElement and the names of the nesting packages. The name is
	* constructed working inwards from the package that is defined as namespace root up to and including
	* the PackageableElement itself.
	* @param {string} separator The string to use to separate names. If not specified, a dot "." will be
	* used.
	* @returns {string} A single string with all the names separated.
	*/
	public getQualifiedName(separator?: string): string
	{
		return this.modelDelegate.getQualifiedName(this, separator);
	}

	/**
	* Gets all types that are owned by this Package. This includes the following types of elements: Class,
	* Interface, DataType, PrimitiveType and Enumeration.
	* @returns {elements.Classifier[]} A subset of PackagedElements.
	*/
	public getTypes(): elements.Classifier[]
	{
		return this.modelDelegate.getTypes(this);
	}

	public addAppliedStereotype(stereotype: elements.Stereotype): this
	{
		this.appliedStereotypes.push(stereotype);
		this.modelDelegate.onAppliedStereotypeAdded(this, stereotype);
		return this;
	}

	public addOwnedComment(properties: editable.CommentProperties): this
	{
		this.ownedComments.push(this.modelDelegate.createElement('comment', this, properties, null));
		return this;
	}

	public addAppliedProfile(profile: elements.Profile): this
	{
		this.appliedProfiles.push(profile);
		this.modelDelegate.onAppliedProfileAdded(this, profile);
		return this;
	}

	public addPackage(properties: editable.PackageProperties, initFn?: (pack: editable.PackageEditable) => void): this
	{
		this.packagedElements.push(this.modelDelegate.createElement('package', this, properties, initFn || null));
		return this;
	}
	public addProfile(properties: editable.ProfileProperties, initFn?: (profile: editable.ProfileEditable) => void): this
	{
		this.packagedElements.push(this.modelDelegate.createElement('profile', this, properties, initFn || null));
		return this;
	}
	public addAssociation(properties: editable.AssociationProperties, initFn?: (association: editable.AssociationEditable) => void): this
	{
		this.packagedElements.push(this.modelDelegate.createElement('association', this, properties, initFn || null));
		return this;
	}
	public addClass(properties: editable.ClassProperties, initFn?: (cls: editable.ClassEditable) => void): this
	{
		this.packagedElements.push(this.modelDelegate.createElement('class', this, properties, initFn || null));
		return this;
	}
	public addStereotype(properties: editable.StereotypeProperties, initFn?: (stereotype: editable.StereotypeEditable) => void): this
	{
		this.packagedElements.push(this.modelDelegate.createElement('stereotype', this, properties, initFn || null));
		return this;
	}
	public addDataType(properties: editable.DataTypeProperties, initFn?: (dataType: editable.DataTypeEditable) => void): this
	{
		this.packagedElements.push(this.modelDelegate.createElement('dataType', this, properties, initFn || null));
		return this;
	}
	public addEnumeration(properties: editable.EnumerationProperties, initFn?: (enumeration: editable.EnumerationEditable) => void): this
	{
		this.packagedElements.push(this.modelDelegate.createElement('enumeration', this, properties, initFn || null));
		return this;
	}
	public addPrimitiveType(properties: editable.PrimitiveTypeProperties, initFn?: (primitiveType: editable.PrimitiveTypeEditable) => void): this
	{
		this.packagedElements.push(this.modelDelegate.createElement('primitiveType', this, properties, initFn || null));
		return this;
	}
	public addInterface(properties: editable.InterfaceProperties, initFn?: (iface: editable.InterfaceEditable) => void): this
	{
		this.packagedElements.push(this.modelDelegate.createElement('interface', this, properties, initFn || null));
		return this;
	}
}

export class DataType extends Element implements elements.DataType, editable.DataTypeEditable {
	constructor(modelDelegate:ModelDelegate, owner: elements.Element | null) {super(modelDelegate, owner);}

	public readonly elementType:elements.ElementType = elements.ElementType.dataType;

	public appliedStereotypes: elements.Stereotype[] = [];

	public generalizations: elements.Generalization[] = [];

	public isAbstract: boolean = false;

	public isDeprecated: boolean = false;

	public isFinalSpecialization: boolean = false;

	public isInferred: boolean = false;

	public isLeaf: boolean = false;

	public name: string = '';

	public ownedAttributes: elements.Property[] = [];

	public ownedOperations: elements.Operation[] = [];

	public get package(): elements.Package {
		return this.modelDelegate.getPackage(this);
	}

	public taggedValues: elements.TaggedValueSpecification[] = [];

	public visibility: elements.VisibilityKind | null = null;

	/**
	* Returns both inherited and owned attributes.
	* @returns {elements.Property[]}
	*/
	public getAllAttributes(): elements.Property[]
	{
		return this.modelDelegate.getAllAttributes(this);
	}

	/**
	* Returns both inherited and owned operations. Any inherited operation that has the same signature
	* (having the same name and parameter type order) in an inheriting type is not included.
	* @returns {elements.Operation[]}
	*/
	public getAllOperations(): elements.Operation[]
	{
		return this.modelDelegate.getAllOperations(this);
	}

	/**
	* Returns all of the direct and indirect ancestors of a generalized Classifier, working outwards: more
	* specific classifiers will appear before more general classifiers.
	* @returns {elements.Classifier[]}
	*/
	public getAllParents(): elements.Classifier[]
	{
		return this.modelDelegate.getAllParents(this);
	}

	/**
	* Gets all classifiers of which this element is a direct or indirect general.
	* @returns {elements.Classifier[]}
	*/
	public getAllSpecializations(): elements.Classifier[]
	{
		return this.modelDelegate.getAllSpecializations(this);
	}

	/**
	* Gets the first direct generalization relationship of the element.
	* @returns {elements.Generalization}
	*/
	public getFirstGeneralization(): elements.Generalization | null
	{
		return this.modelDelegate.getFirstGeneralization(this);
	}

	/**
	* Gets the first classifier that is an immediate general of the current element.
	* @returns {elements.Classifier}
	*/
	public getFirstParent(): elements.Classifier | null
	{
		return this.modelDelegate.getFirstParent(this);
	}

	/**
	* Constructs a name from the names of the nesting packages. The name is constructed working inwards
	* from the package that is defined as namespace root up to but not including the PackageableElement
	* itself.
	* @param {string} separator The string to use to separate names. If not specified, a dot "." will be
	* used.
	* @returns {string} A single string with all the names separated.
	*/
	public getNamespaceName(separator?: string): string
	{
		return this.modelDelegate.getNamespaceName(this, separator);
	}

	/**
	* Gets all packages that contain this Package, working inwards from the top Package to the owning
	* package.
	* @returns {elements.Package[]} A collection of Packages.
	*/
	public getNestingPackages(): elements.Package[]
	{
		return this.modelDelegate.getNestingPackages(this);
	}

	/**
	* Gives all of the immediate ancestors of a generalized Classifier.
	* @returns {elements.Classifier[]}
	*/
	public getParents(): elements.Classifier[]
	{
		return this.modelDelegate.getParents(this);
	}

	/**
	* Constructs a name from the PackageableElement and the names of the nesting packages. The name is
	* constructed working inwards from the package that is defined as namespace root up to and including
	* the PackageableElement itself.
	* @param {string} separator The string to use to separate names. If not specified, a dot "." will be
	* used.
	* @returns {string} A single string with all the names separated.
	*/
	public getQualifiedName(separator?: string): string
	{
		return this.modelDelegate.getQualifiedName(this, separator);
	}

	/**
	* Gets all classifiers of which this classifier is a direct general.
	* @returns {elements.Classifier[]}
	*/
	public getSpecializations(): elements.Classifier[]
	{
		return this.modelDelegate.getSpecializations(this);
	}

	public addAppliedStereotype(stereotype: elements.Stereotype): this
	{
		this.appliedStereotypes.push(stereotype);
		this.modelDelegate.onAppliedStereotypeAdded(this, stereotype);
		return this;
	}

	public addOwnedComment(properties: editable.CommentProperties): this
	{
		this.ownedComments.push(this.modelDelegate.createElement('comment', this, properties, null));
		return this;
	}

	public addGeneralization(properties: editable.GeneralizationProperties, initFn?: (generalization: editable.GeneralizationEditable) => void): this
	{
		this.generalizations.push(this.modelDelegate.createElement('generalization', this, properties, initFn || null));
		return this;
	}

	public addOwnedAttribute(properties: editable.PropertyProperties, initFn?: (property: editable.PropertyEditable) => void): this
	{
		this.ownedAttributes.push(this.modelDelegate.createElement('property', this, properties, initFn || null));
		return this;
	}

	public addOwnedOperation(properties: editable.OperationProperties, initFn?: (operation: editable.OperationEditable) => void): this
	{
		this.ownedOperations.push(this.modelDelegate.createElement('operation', this, properties, initFn || null));
		return this;
	}
}

export class PrimitiveType extends Element implements elements.PrimitiveType, editable.PrimitiveTypeEditable {
	constructor(modelDelegate:ModelDelegate, owner: elements.Element | null) {super(modelDelegate, owner);}

	public readonly elementType:elements.ElementType = elements.ElementType.primitiveType;

	public appliedStereotypes: elements.Stereotype[] = [];

	public generalizations: elements.Generalization[] = [];

	public isAbstract: boolean = false;

	public isDeprecated: boolean = false;

	public isFinalSpecialization: boolean = false;

	public isInferred: boolean = false;

	public isLeaf: boolean = false;

	public name: string = '';

	public ownedAttributes: elements.Property[] = [];

	public ownedOperations: elements.Operation[] = [];

	public get package(): elements.Package {
		return this.modelDelegate.getPackage(this);
	}

	public taggedValues: elements.TaggedValueSpecification[] = [];

	public visibility: elements.VisibilityKind | null = null;

	/**
	* Returns both inherited and owned attributes.
	* @returns {elements.Property[]}
	*/
	public getAllAttributes(): elements.Property[]
	{
		return this.modelDelegate.getAllAttributes(this);
	}

	/**
	* Returns both inherited and owned operations. Any inherited operation that has the same signature
	* (having the same name and parameter type order) in an inheriting type is not included.
	* @returns {elements.Operation[]}
	*/
	public getAllOperations(): elements.Operation[]
	{
		return this.modelDelegate.getAllOperations(this);
	}

	/**
	* Returns all of the direct and indirect ancestors of a generalized Classifier, working outwards: more
	* specific classifiers will appear before more general classifiers.
	* @returns {elements.Classifier[]}
	*/
	public getAllParents(): elements.Classifier[]
	{
		return this.modelDelegate.getAllParents(this);
	}

	/**
	* Gets all classifiers of which this element is a direct or indirect general.
	* @returns {elements.Classifier[]}
	*/
	public getAllSpecializations(): elements.Classifier[]
	{
		return this.modelDelegate.getAllSpecializations(this);
	}

	/**
	* Gets the first direct generalization relationship of the element.
	* @returns {elements.Generalization}
	*/
	public getFirstGeneralization(): elements.Generalization | null
	{
		return this.modelDelegate.getFirstGeneralization(this);
	}

	/**
	* Gets the first classifier that is an immediate general of the current element.
	* @returns {elements.Classifier}
	*/
	public getFirstParent(): elements.Classifier | null
	{
		return this.modelDelegate.getFirstParent(this);
	}

	/**
	* Constructs a name from the names of the nesting packages. The name is constructed working inwards
	* from the package that is defined as namespace root up to but not including the PackageableElement
	* itself.
	* @param {string} separator The string to use to separate names. If not specified, a dot "." will be
	* used.
	* @returns {string} A single string with all the names separated.
	*/
	public getNamespaceName(separator?: string): string
	{
		return this.modelDelegate.getNamespaceName(this, separator);
	}

	/**
	* Gets all packages that contain this Package, working inwards from the top Package to the owning
	* package.
	* @returns {elements.Package[]} A collection of Packages.
	*/
	public getNestingPackages(): elements.Package[]
	{
		return this.modelDelegate.getNestingPackages(this);
	}

	/**
	* Gives all of the immediate ancestors of a generalized Classifier.
	* @returns {elements.Classifier[]}
	*/
	public getParents(): elements.Classifier[]
	{
		return this.modelDelegate.getParents(this);
	}

	/**
	* Constructs a name from the PackageableElement and the names of the nesting packages. The name is
	* constructed working inwards from the package that is defined as namespace root up to and including
	* the PackageableElement itself.
	* @param {string} separator The string to use to separate names. If not specified, a dot "." will be
	* used.
	* @returns {string} A single string with all the names separated.
	*/
	public getQualifiedName(separator?: string): string
	{
		return this.modelDelegate.getQualifiedName(this, separator);
	}

	/**
	* Gets all classifiers of which this classifier is a direct general.
	* @returns {elements.Classifier[]}
	*/
	public getSpecializations(): elements.Classifier[]
	{
		return this.modelDelegate.getSpecializations(this);
	}

	public addAppliedStereotype(stereotype: elements.Stereotype): this
	{
		this.appliedStereotypes.push(stereotype);
		this.modelDelegate.onAppliedStereotypeAdded(this, stereotype);
		return this;
	}

	public addOwnedComment(properties: editable.CommentProperties): this
	{
		this.ownedComments.push(this.modelDelegate.createElement('comment', this, properties, null));
		return this;
	}

	public addGeneralization(properties: editable.GeneralizationProperties, initFn?: (generalization: editable.GeneralizationEditable) => void): this
	{
		this.generalizations.push(this.modelDelegate.createElement('generalization', this, properties, initFn || null));
		return this;
	}

	public addOwnedAttribute(properties: editable.PropertyProperties, initFn?: (property: editable.PropertyEditable) => void): this
	{
		this.ownedAttributes.push(this.modelDelegate.createElement('property', this, properties, initFn || null));
		return this;
	}

	public addOwnedOperation(properties: editable.OperationProperties, initFn?: (operation: editable.OperationEditable) => void): this
	{
		this.ownedOperations.push(this.modelDelegate.createElement('operation', this, properties, initFn || null));
		return this;
	}
}

export class Parameter extends Element implements elements.Parameter, editable.ParameterEditable {
	constructor(modelDelegate:ModelDelegate, owner: elements.Element | null) {super(modelDelegate, owner);}

	public readonly elementType:elements.ElementType = elements.ElementType.parameter;

	public appliedStereotypes: elements.Stereotype[] = [];

	public defaultValue: elements.ValueSpecification | null = null;

	public direction: elements.ParameterDirectionKind = elements.ParameterDirectionKind.in;

	public isDeprecated: boolean = false;

	public isException: boolean = false;

	public isOrdered: boolean = false;

	public isStream: boolean = false;

	public isUnique: boolean = false;

	public get lower(): number | null {
		return this.modelDelegate.getLower(this);
	}

	public lowerValue: elements.ValueSpecification | null = null;

	public name: string = '';

	public order: number = 0;

	public taggedValues: elements.TaggedValueSpecification[] = [];

	public type: elements.Type | null = null;

	public get upper(): elements.UnlimitedNatural | null {
		return this.modelDelegate.getUpper(this);
	}

	public upperValue: elements.ValueSpecification | null = null;

	public visibility: elements.VisibilityKind | null = null;

	/**
	* Gets the value of the DefaultValue property.
	* @returns {any} The default value (the type depending on the type of value), or null if no default
	* value can be determined.
	*/
	public getDefault(): any | null
	{
		return this.modelDelegate.getDefault(this);
	}

	/**
	* The query lowerBound() returns the lower bound of the multiplicity as an integer, which is the
	* integerValue of lowerValue, if this is given, and 1 otherwise.
	* @returns {number}
	*/
	public getLowerBound(): number
	{
		return this.modelDelegate.getLowerBound(this);
	}

	/**
	* Gets the name of the typed element's type.
	* @returns {string} The type name, or an empty string if the element has no type.
	*/
	public getTypeName(): string
	{
		return this.modelDelegate.getTypeName(this);
	}

	/**
	* The query upperBound() returns the upper bound of the multiplicity for a bounded multiplicity as an
	* unlimited natural, which is the unlimitedNaturalValue of upperValue, if given, and 1, otherwise.
	* @returns {elements.UnlimitedNatural}
	*/
	public getUpperBound(): elements.UnlimitedNatural
	{
		return this.modelDelegate.getUpperBound(this);
	}

	/**
	* The query isMultivalued() checks whether this multiplicity has an upper bound greater than one.
	* @returns {boolean}
	*/
	public isMultivalued(): boolean
	{
		return this.modelDelegate.isMultivalued(this);
	}

	/**
	* The query isOptional checks whether this multiplicity has a lower bound of 0 (0..n).
	* @returns {boolean}
	*/
	public isOptional(): boolean
	{
		return this.modelDelegate.isOptional(this);
	}

	/**
	* The query isOptionalAndSingleValued checks whether this multiplicity has a lower bound of 0 and an
	* upper bound of 1 (0..1).
	* @returns {boolean}
	*/
	public isOptionalAndSinglevalued(): boolean
	{
		return this.modelDelegate.isOptionalAndSinglevalued(this);
	}

	/**
	* The query isRequiredAndSinglevalued checks whether this multiplicity has a lower bound of 1 and an
	* upper bound of 1 (1..1).
	* @returns {boolean}
	*/
	public isRequiredAndSinglevalued(): boolean
	{
		return this.modelDelegate.isRequiredAndSinglevalued(this);
	}

	public addAppliedStereotype(stereotype: elements.Stereotype): this
	{
		this.appliedStereotypes.push(stereotype);
		this.modelDelegate.onAppliedStereotypeAdded(this, stereotype);
		return this;
	}

	public addOwnedComment(properties: editable.CommentProperties): this
	{
		this.ownedComments.push(this.modelDelegate.createElement('comment', this, properties, null));
		return this;
	}

	public setLowerValueUnlimited(): this
	{
		this.modelDelegate.setLowerValueUnlimited(this);
		return this;
	}

	public setLowerValue(value: number): this
	{
		this.modelDelegate.setLowerValue(this, value);
		return this;
	}

	public setUpperValueUnlimited(): this
	{
		this.modelDelegate.setUpperValueUnlimited(this);
		return this;
	}

	public setUpperValue(value: number): this
	{
		this.modelDelegate.setUpperValue(this, value);
		return this;
	}

	public setDefaultValueNull(): this
	{
		this.modelDelegate.setDefaultValueNull(this);
		return this;
	}

	public setDefaultValue(value: boolean): this;
	public setDefaultValue(value: number): this;
	public setDefaultValue(value: string): this;
	public setDefaultValue(value: any): this
	{
		this.modelDelegate.setDefaultValue(this, value);
		return this;
	}
}

export class Operation extends Element implements elements.Operation, editable.OperationEditable {
	constructor(modelDelegate:ModelDelegate, owner: elements.Element | null) {super(modelDelegate, owner);}

	public readonly elementType:elements.ElementType = elements.ElementType.operation;

	public appliedStereotypes: elements.Stereotype[] = [];

	public isAbstract: boolean = false;

	public isConstructor: boolean = false;

	public isDeprecated: boolean = false;

	public isLeaf: boolean = false;

	public isQuery: boolean = false;

	public isStatic: boolean = false;

	public get lower(): number | null {
		return this.modelDelegate.getLower(this);
	}

	public name: string = '';

	public order: number = 0;

	public ownedParameters: elements.Parameter[] = [];

	public taggedValues: elements.TaggedValueSpecification[] = [];

	public get upper(): elements.UnlimitedNatural | null {
		return this.modelDelegate.getUpper(this);
	}

	public visibility: elements.VisibilityKind | null = null;

	/**
	* Returns the ownedParameters with direction in and inout.
	* @returns {elements.Parameter[]}
	*/
	public getInputParameters(): elements.Parameter[]
	{
		return this.modelDelegate.getInputParameters(this);
	}

	/**
	* The query lowerBound() returns the lower bound of the return parameter as an integer, which is the
	* integerValue of lowerValue, if this is given, and 1 otherwise. This information is derived from the
	* return result for this Operation.
	* @returns {number}
	*/
	public getLowerBound(): number
	{
		return this.modelDelegate.getLowerBound(this);
	}

	/**
	* Returns the ownedParameters with direction out, inout, or return.
	* @returns {elements.Parameter[]}
	*/
	public getOutputParameters(): elements.Parameter[]
	{
		return this.modelDelegate.getOutputParameters(this);
	}

	/**
	* Gets the operation's return parameter, if it has one.
	* @returns {elements.Parameter}
	*/
	public getReturnParameter(): elements.Parameter | null
	{
		return this.modelDelegate.getReturnParameter(this);
	}

	/**
	* Gets the type of the operation's return parameter, if it has any.
	* @returns {elements.Type}
	*/
	public getReturnType(): elements.Type | null
	{
		return this.modelDelegate.getReturnType(this);
	}

	/**
	* The query upperBound() returns the upper bound of the return parameter for a bounded multiplicity as
	* an unlimited natural, which is the unlimitedNaturalValue of upperValue, if given, and 1, otherwise.
	* This information is derived from the return result for this Operation.
	* @returns {elements.UnlimitedNatural}
	*/
	public getUpperBound(): elements.UnlimitedNatural
	{
		return this.modelDelegate.getUpperBound(this);
	}

	/**
	* The query isMultivalued() checks whether the return parameter has an upper bound greater than one.
	* @returns {boolean}
	*/
	public isMultivalued(): boolean
	{
		return this.modelDelegate.isMultivalued(this);
	}

	/**
	* The query isOptional checks whether he return parameter has a lower bound of 0 (0..n).
	* @returns {boolean}
	*/
	public isOptional(): boolean
	{
		return this.modelDelegate.isOptional(this);
	}

	/**
	* The query isOptional checks whether he return parameter has a lower bound of 0 and an upper bound of
	* 1 (0..1).
	* @returns {boolean}
	*/
	public isOptionalAndSinglevalued(): boolean
	{
		return this.modelDelegate.isOptionalAndSinglevalued(this);
	}

	public addAppliedStereotype(stereotype: elements.Stereotype): this
	{
		this.appliedStereotypes.push(stereotype);
		this.modelDelegate.onAppliedStereotypeAdded(this, stereotype);
		return this;
	}

	public addOwnedComment(properties: editable.CommentProperties): this
	{
		this.ownedComments.push(this.modelDelegate.createElement('comment', this, properties, null));
		return this;
	}

	public addOwnedParameter(properties: editable.ParameterProperties, initFn?: (parameter: editable.ParameterEditable) => void): this
	{
		this.ownedParameters.push(this.modelDelegate.createElement('parameter', this, properties, initFn || null));
		return this;
	}
}

export class Model extends Element implements elements.Model, editable.ModelEditable {
	constructor(modelDelegate:ModelDelegate, owner: elements.Element | null) {super(modelDelegate, owner);}

	public readonly elementType:elements.ElementType = elements.ElementType.model;

	public appliedProfiles: elements.Profile[] = [];

	public appliedStereotypes: elements.Stereotype[] = [];

	public isDeprecated: boolean = false;

	public isNamespaceRoot: boolean = false;

	public name: string = '';

	public get package(): elements.Package {
		return this.modelDelegate.getPackage(this);
	}

	public packagedElements: elements.PackageableElement[] = [];

	public taggedValues: elements.TaggedValueSpecification[] = [];

	public visibility: elements.VisibilityKind | null = null;

	/**
	* Gets all classes that are owned by this Package, including the ones owned by nested packages.
	* @returns {elements.Class[]}
	*/
	public getAllClasses(): elements.Class[]
	{
		return this.modelDelegate.getAllClasses(this);
	}

	/**
	* Gets all data types that are owned by this Package, including the ones owned by nested packages.
	* @returns {elements.DataType[]}
	*/
	public getAllDataTypes(): elements.DataType[]
	{
		return this.modelDelegate.getAllDataTypes(this);
	}

	/**
	* Gets all enumerations that are owned by this Package, including the ones owned by nested packages.
	* @returns {elements.Enumeration[]}
	*/
	public getAllEnumerations(): elements.Enumeration[]
	{
		return this.modelDelegate.getAllEnumerations(this);
	}

	/**
	* Gets all interfaces that are owned by this Package, including the ones owned by nested packages.
	* @returns {elements.Interface[]}
	*/
	public getAllInterfaces(): elements.Interface[]
	{
		return this.modelDelegate.getAllInterfaces(this);
	}

	/**
	* Gets all types that are owned by this Package, including the ones owned by nested packages. This
	* includes the following types of elements: Class, Interface, DataType, PrimitiveType and Enumeration.
	* @returns {elements.Classifier[]} A subset of PackagedElements.
	*/
	public getAllTypes(): elements.Classifier[]
	{
		return this.modelDelegate.getAllTypes(this);
	}

	/**
	* Gets all classes that are owned by this Package.
	* @returns {elements.Class[]} A subset of PackagedElements.
	*/
	public getClasses(): elements.Class[]
	{
		return this.modelDelegate.getClasses(this);
	}

	/**
	* Gets all data types that are owned by this Package.
	* @returns {elements.DataType[]} A subset of PackagedElements.
	*/
	public getDataTypes(): elements.DataType[]
	{
		return this.modelDelegate.getDataTypes(this);
	}

	/**
	* Gets all enumerations that are owned by this Package.
	* @returns {elements.Enumeration[]} A subset of PackagedElements.
	*/
	public getEnumerations(): elements.Enumeration[]
	{
		return this.modelDelegate.getEnumerations(this);
	}

	/**
	* Gets all interfaces that are owned by this Package.
	* @returns {elements.Interface[]} A subset of PackagedElements.
	*/
	public getInterfaces(): elements.Interface[]
	{
		return this.modelDelegate.getInterfaces(this);
	}

	/**
	* Constructs a name from the names of the nesting packages. The name is constructed working inwards
	* from the package that is defined as namespace root up to but not including the PackageableElement
	* itself.
	* @param {string} separator The string to use to separate names. If not specified, a dot "." will be
	* used.
	* @returns {string} A single string with all the names separated.
	*/
	public getNamespaceName(separator?: string): string
	{
		return this.modelDelegate.getNamespaceName(this, separator);
	}

	/**
	* Gets all packages that are owned by this Package.
	* @returns {elements.Package[]} A subset of PackagedElements.
	*/
	public getNestedPackages(): elements.Package[]
	{
		return this.modelDelegate.getNestedPackages(this);
	}

	/**
	* Gets all packages that contain this Package, working inwards from the top Package to the owning
	* package.
	* @returns {elements.Package[]} A collection of Packages.
	*/
	public getNestingPackages(): elements.Package[]
	{
		return this.modelDelegate.getNestingPackages(this);
	}

	/**
	* Constructs a name from the PackageableElement and the names of the nesting packages. The name is
	* constructed working inwards from the package that is defined as namespace root up to and including
	* the PackageableElement itself.
	* @param {string} separator The string to use to separate names. If not specified, a dot "." will be
	* used.
	* @returns {string} A single string with all the names separated.
	*/
	public getQualifiedName(separator?: string): string
	{
		return this.modelDelegate.getQualifiedName(this, separator);
	}

	/**
	* Gets all types that are owned by this Package. This includes the following types of elements: Class,
	* Interface, DataType, PrimitiveType and Enumeration.
	* @returns {elements.Classifier[]} A subset of PackagedElements.
	*/
	public getTypes(): elements.Classifier[]
	{
		return this.modelDelegate.getTypes(this);
	}

	public addAppliedStereotype(stereotype: elements.Stereotype): this
	{
		this.appliedStereotypes.push(stereotype);
		this.modelDelegate.onAppliedStereotypeAdded(this, stereotype);
		return this;
	}

	public addOwnedComment(properties: editable.CommentProperties): this
	{
		this.ownedComments.push(this.modelDelegate.createElement('comment', this, properties, null));
		return this;
	}

	public addAppliedProfile(profile: elements.Profile): this
	{
		this.appliedProfiles.push(profile);
		this.modelDelegate.onAppliedProfileAdded(this, profile);
		return this;
	}

	public addPackage(properties: editable.PackageProperties, initFn?: (pack: editable.PackageEditable) => void): this
	{
		this.packagedElements.push(this.modelDelegate.createElement('package', this, properties, initFn || null));
		return this;
	}
	public addProfile(properties: editable.ProfileProperties, initFn?: (profile: editable.ProfileEditable) => void): this
	{
		this.packagedElements.push(this.modelDelegate.createElement('profile', this, properties, initFn || null));
		return this;
	}
	public addAssociation(properties: editable.AssociationProperties, initFn?: (association: editable.AssociationEditable) => void): this
	{
		this.packagedElements.push(this.modelDelegate.createElement('association', this, properties, initFn || null));
		return this;
	}
	public addClass(properties: editable.ClassProperties, initFn?: (cls: editable.ClassEditable) => void): this
	{
		this.packagedElements.push(this.modelDelegate.createElement('class', this, properties, initFn || null));
		return this;
	}
	public addStereotype(properties: editable.StereotypeProperties, initFn?: (stereotype: editable.StereotypeEditable) => void): this
	{
		this.packagedElements.push(this.modelDelegate.createElement('stereotype', this, properties, initFn || null));
		return this;
	}
	public addDataType(properties: editable.DataTypeProperties, initFn?: (dataType: editable.DataTypeEditable) => void): this
	{
		this.packagedElements.push(this.modelDelegate.createElement('dataType', this, properties, initFn || null));
		return this;
	}
	public addEnumeration(properties: editable.EnumerationProperties, initFn?: (enumeration: editable.EnumerationEditable) => void): this
	{
		this.packagedElements.push(this.modelDelegate.createElement('enumeration', this, properties, initFn || null));
		return this;
	}
	public addPrimitiveType(properties: editable.PrimitiveTypeProperties, initFn?: (primitiveType: editable.PrimitiveTypeEditable) => void): this
	{
		this.packagedElements.push(this.modelDelegate.createElement('primitiveType', this, properties, initFn || null));
		return this;
	}
	public addInterface(properties: editable.InterfaceProperties, initFn?: (iface: editable.InterfaceEditable) => void): this
	{
		this.packagedElements.push(this.modelDelegate.createElement('interface', this, properties, initFn || null));
		return this;
	}
}

export class LiteralUnlimitedNatural extends Element implements elements.LiteralUnlimitedNatural {
	constructor(modelDelegate:ModelDelegate, owner: elements.Element | null) {super(modelDelegate, owner);}

	public readonly elementType:elements.ElementType = elements.ElementType.literalUnlimitedNatural;

	public appliedStereotypes: elements.Stereotype[] = [];

	public isDeprecated: boolean = false;

	public name: string = '';

	public taggedValues: elements.TaggedValueSpecification[] = [];

	public type: elements.Type | null = null;

	public value!: elements.UnlimitedNatural;

	public visibility: elements.VisibilityKind | null = null;

	/**
	* Gets the string representation of the value.
	* @returns {string}
	*/
	public getStringValue(): string
	{
		return this.modelDelegate.getStringValue(this);
	}

	/**
	* Gets the name of the typed element's type.
	* @returns {string} The type name, or an empty string if the element has no type.
	*/
	public getTypeName(): string
	{
		return this.modelDelegate.getTypeName(this);
	}

	/**
	* Gets underlying value of the ValueSpecification. The type depends on the type of ValueSpecification.
	* @returns {any} The underlying value of the ValueSpecification. The type depends on the type of
	* ValueSpecification.
	*/
	public getValue(): any | null
	{
		return this.modelDelegate.getValue(this);
	}
}

export class LiteralString extends Element implements elements.LiteralString {
	constructor(modelDelegate:ModelDelegate, owner: elements.Element | null) {super(modelDelegate, owner);}

	public readonly elementType:elements.ElementType = elements.ElementType.literalString;

	public appliedStereotypes: elements.Stereotype[] = [];

	public isDeprecated: boolean = false;

	public name: string = '';

	public taggedValues: elements.TaggedValueSpecification[] = [];

	public type: elements.Type | null = null;

	public value: string = '';

	public visibility: elements.VisibilityKind | null = null;

	/**
	* Gets the string representation of the value.
	* @returns {string}
	*/
	public getStringValue(): string
	{
		return this.modelDelegate.getStringValue(this);
	}

	/**
	* Gets the name of the typed element's type.
	* @returns {string} The type name, or an empty string if the element has no type.
	*/
	public getTypeName(): string
	{
		return this.modelDelegate.getTypeName(this);
	}

	/**
	* Gets underlying value of the ValueSpecification. The type depends on the type of ValueSpecification.
	* @returns {any} The underlying value of the ValueSpecification. The type depends on the type of
	* ValueSpecification.
	*/
	public getValue(): any | null
	{
		return this.modelDelegate.getValue(this);
	}
}

export class LiteralReal extends Element implements elements.LiteralReal {
	constructor(modelDelegate:ModelDelegate, owner: elements.Element | null) {super(modelDelegate, owner);}

	public readonly elementType:elements.ElementType = elements.ElementType.literalReal;

	public appliedStereotypes: elements.Stereotype[] = [];

	public isDeprecated: boolean = false;

	public name: string = '';

	public taggedValues: elements.TaggedValueSpecification[] = [];

	public type: elements.Type | null = null;

	public value: number = 0;

	public visibility: elements.VisibilityKind | null = null;

	/**
	* Gets the string representation of the value.
	* @returns {string}
	*/
	public getStringValue(): string
	{
		return this.modelDelegate.getStringValue(this);
	}

	/**
	* Gets the name of the typed element's type.
	* @returns {string} The type name, or an empty string if the element has no type.
	*/
	public getTypeName(): string
	{
		return this.modelDelegate.getTypeName(this);
	}

	/**
	* Gets underlying value of the ValueSpecification. The type depends on the type of ValueSpecification.
	* @returns {any} The underlying value of the ValueSpecification. The type depends on the type of
	* ValueSpecification.
	*/
	public getValue(): any | null
	{
		return this.modelDelegate.getValue(this);
	}
}

export class LiteralNull extends Element implements elements.LiteralNull {
	constructor(modelDelegate:ModelDelegate, owner: elements.Element | null) {super(modelDelegate, owner);}

	public readonly elementType:elements.ElementType = elements.ElementType.literalNull;

	public appliedStereotypes: elements.Stereotype[] = [];

	public isDeprecated: boolean = false;

	public name: string = '';

	public taggedValues: elements.TaggedValueSpecification[] = [];

	public type: elements.Type | null = null;

	public visibility: elements.VisibilityKind | null = null;

	/**
	* Gets the string representation of the value.
	* @returns {string}
	*/
	public getStringValue(): string
	{
		return this.modelDelegate.getStringValue(this);
	}

	/**
	* Gets the name of the typed element's type.
	* @returns {string} The type name, or an empty string if the element has no type.
	*/
	public getTypeName(): string
	{
		return this.modelDelegate.getTypeName(this);
	}

	/**
	* Gets underlying value of the ValueSpecification. The type depends on the type of ValueSpecification.
	* @returns {any} The underlying value of the ValueSpecification. The type depends on the type of
	* ValueSpecification.
	*/
	public getValue(): any | null
	{
		return this.modelDelegate.getValue(this);
	}
}

export class LiteralInteger extends Element implements elements.LiteralInteger {
	constructor(modelDelegate:ModelDelegate, owner: elements.Element | null) {super(modelDelegate, owner);}

	public readonly elementType:elements.ElementType = elements.ElementType.literalInteger;

	public appliedStereotypes: elements.Stereotype[] = [];

	public isDeprecated: boolean = false;

	public name: string = '';

	public taggedValues: elements.TaggedValueSpecification[] = [];

	public type: elements.Type | null = null;

	public value: number = 0;

	public visibility: elements.VisibilityKind | null = null;

	/**
	* Gets the string representation of the value.
	* @returns {string}
	*/
	public getStringValue(): string
	{
		return this.modelDelegate.getStringValue(this);
	}

	/**
	* Gets the name of the typed element's type.
	* @returns {string} The type name, or an empty string if the element has no type.
	*/
	public getTypeName(): string
	{
		return this.modelDelegate.getTypeName(this);
	}

	/**
	* Gets underlying value of the ValueSpecification. The type depends on the type of ValueSpecification.
	* @returns {any} The underlying value of the ValueSpecification. The type depends on the type of
	* ValueSpecification.
	*/
	public getValue(): any | null
	{
		return this.modelDelegate.getValue(this);
	}
}

export class LiteralBoolean extends Element implements elements.LiteralBoolean {
	constructor(modelDelegate:ModelDelegate, owner: elements.Element | null) {super(modelDelegate, owner);}

	public readonly elementType:elements.ElementType = elements.ElementType.literalBoolean;

	public appliedStereotypes: elements.Stereotype[] = [];

	public isDeprecated: boolean = false;

	public name: string = '';

	public taggedValues: elements.TaggedValueSpecification[] = [];

	public type: elements.Type | null = null;

	public value: boolean = false;

	public visibility: elements.VisibilityKind | null = null;

	/**
	* Gets the string representation of the value.
	* @returns {string}
	*/
	public getStringValue(): string
	{
		return this.modelDelegate.getStringValue(this);
	}

	/**
	* Gets the name of the typed element's type.
	* @returns {string} The type name, or an empty string if the element has no type.
	*/
	public getTypeName(): string
	{
		return this.modelDelegate.getTypeName(this);
	}

	/**
	* Gets underlying value of the ValueSpecification. The type depends on the type of ValueSpecification.
	* @returns {any} The underlying value of the ValueSpecification. The type depends on the type of
	* ValueSpecification.
	*/
	public getValue(): any | null
	{
		return this.modelDelegate.getValue(this);
	}
}

export class InterfaceRealization extends Element implements elements.InterfaceRealization, editable.InterfaceRealizationEditable {
	constructor(modelDelegate:ModelDelegate, owner: elements.Element | null) {super(modelDelegate, owner);}

	public readonly elementType:elements.ElementType = elements.ElementType.interfaceRealization;

	public appliedStereotypes: elements.Stereotype[] = [];

	public contract!: elements.Interface;

	public taggedValues: elements.TaggedValueSpecification[] = [];

	public addAppliedStereotype(stereotype: elements.Stereotype): this
	{
		this.appliedStereotypes.push(stereotype);
		this.modelDelegate.onAppliedStereotypeAdded(this, stereotype);
		return this;
	}

	public addOwnedComment(properties: editable.CommentProperties): this
	{
		this.ownedComments.push(this.modelDelegate.createElement('comment', this, properties, null));
		return this;
	}
}

export class Interface extends Element implements elements.Interface, editable.InterfaceEditable {
	constructor(modelDelegate:ModelDelegate, owner: elements.Element | null) {super(modelDelegate, owner);}

	public readonly elementType:elements.ElementType = elements.ElementType.interface;

	public appliedStereotypes: elements.Stereotype[] = [];

	public generalizations: elements.Generalization[] = [];

	public isAbstract: boolean = false;

	public isDeprecated: boolean = false;

	public isFinalSpecialization: boolean = false;

	public isInferred: boolean = false;

	public isLeaf: boolean = false;

	public name: string = '';

	public ownedAttributes: elements.Property[] = [];

	public ownedOperations: elements.Operation[] = [];

	public get package(): elements.Package {
		return this.modelDelegate.getPackage(this);
	}

	public taggedValues: elements.TaggedValueSpecification[] = [];

	public visibility: elements.VisibilityKind | null = null;

	/**
	* Returns both inherited and owned attributes.
	* @returns {elements.Property[]}
	*/
	public getAllAttributes(): elements.Property[]
	{
		return this.modelDelegate.getAllAttributes(this);
	}

	/**
	* Returns both inherited and owned operations. Any inherited operation that has the same signature
	* (having the same name and parameter type order) in an inheriting type is not included.
	* @returns {elements.Operation[]}
	*/
	public getAllOperations(): elements.Operation[]
	{
		return this.modelDelegate.getAllOperations(this);
	}

	/**
	* Returns all of the direct and indirect ancestors of a generalized Classifier, working outwards: more
	* specific classifiers will appear before more general classifiers.
	* @returns {elements.Classifier[]}
	*/
	public getAllParents(): elements.Classifier[]
	{
		return this.modelDelegate.getAllParents(this);
	}

	/**
	* Gets all classifiers of which this element is a direct or indirect general.
	* @returns {elements.Classifier[]}
	*/
	public getAllSpecializations(): elements.Classifier[]
	{
		return this.modelDelegate.getAllSpecializations(this);
	}

	/**
	* Gets the first direct generalization relationship of the element.
	* @returns {elements.Generalization}
	*/
	public getFirstGeneralization(): elements.Generalization | null
	{
		return this.modelDelegate.getFirstGeneralization(this);
	}

	/**
	* Gets the first classifier that is an immediate general of the current element.
	* @returns {elements.Classifier}
	*/
	public getFirstParent(): elements.Classifier | null
	{
		return this.modelDelegate.getFirstParent(this);
	}

	/**
	* Constructs a name from the names of the nesting packages. The name is constructed working inwards
	* from the package that is defined as namespace root up to but not including the PackageableElement
	* itself.
	* @param {string} separator The string to use to separate names. If not specified, a dot "." will be
	* used.
	* @returns {string} A single string with all the names separated.
	*/
	public getNamespaceName(separator?: string): string
	{
		return this.modelDelegate.getNamespaceName(this, separator);
	}

	/**
	* Gets all packages that contain this Package, working inwards from the top Package to the owning
	* package.
	* @returns {elements.Package[]} A collection of Packages.
	*/
	public getNestingPackages(): elements.Package[]
	{
		return this.modelDelegate.getNestingPackages(this);
	}

	/**
	* Gives all of the immediate ancestors of a generalized Classifier.
	* @returns {elements.Classifier[]}
	*/
	public getParents(): elements.Classifier[]
	{
		return this.modelDelegate.getParents(this);
	}

	/**
	* Constructs a name from the PackageableElement and the names of the nesting packages. The name is
	* constructed working inwards from the package that is defined as namespace root up to and including
	* the PackageableElement itself.
	* @param {string} separator The string to use to separate names. If not specified, a dot "." will be
	* used.
	* @returns {string} A single string with all the names separated.
	*/
	public getQualifiedName(separator?: string): string
	{
		return this.modelDelegate.getQualifiedName(this, separator);
	}

	/**
	* Gets all classifiers of which this classifier is a direct general.
	* @returns {elements.Classifier[]}
	*/
	public getSpecializations(): elements.Classifier[]
	{
		return this.modelDelegate.getSpecializations(this);
	}

	public addAppliedStereotype(stereotype: elements.Stereotype): this
	{
		this.appliedStereotypes.push(stereotype);
		this.modelDelegate.onAppliedStereotypeAdded(this, stereotype);
		return this;
	}

	public addOwnedComment(properties: editable.CommentProperties): this
	{
		this.ownedComments.push(this.modelDelegate.createElement('comment', this, properties, null));
		return this;
	}

	public addGeneralization(properties: editable.GeneralizationProperties, initFn?: (generalization: editable.GeneralizationEditable) => void): this
	{
		this.generalizations.push(this.modelDelegate.createElement('generalization', this, properties, initFn || null));
		return this;
	}

	public addOwnedAttribute(properties: editable.PropertyProperties, initFn?: (property: editable.PropertyEditable) => void): this
	{
		this.ownedAttributes.push(this.modelDelegate.createElement('property', this, properties, initFn || null));
		return this;
	}

	public addOwnedOperation(properties: editable.OperationProperties, initFn?: (operation: editable.OperationEditable) => void): this
	{
		this.ownedOperations.push(this.modelDelegate.createElement('operation', this, properties, initFn || null));
		return this;
	}
}

export class Generalization extends Element implements elements.Generalization, editable.GeneralizationEditable {
	constructor(modelDelegate:ModelDelegate, owner: elements.Element | null) {super(modelDelegate, owner);}

	public readonly elementType:elements.ElementType = elements.ElementType.generalization;

	public appliedStereotypes: elements.Stereotype[] = [];

	public general!: elements.Classifier;

	public isSubstitutable: boolean = false;

	public get specific(): elements.Classifier {
		return this.modelDelegate.getSpecific(this);
	}

	public taggedValues: elements.TaggedValueSpecification[] = [];

	public addAppliedStereotype(stereotype: elements.Stereotype): this
	{
		this.appliedStereotypes.push(stereotype);
		this.modelDelegate.onAppliedStereotypeAdded(this, stereotype);
		return this;
	}

	public addOwnedComment(properties: editable.CommentProperties): this
	{
		this.ownedComments.push(this.modelDelegate.createElement('comment', this, properties, null));
		return this;
	}
}

export class EnumerationLiteral extends Element implements elements.EnumerationLiteral, editable.EnumerationLiteralEditable {
	constructor(modelDelegate:ModelDelegate, owner: elements.Element | null) {super(modelDelegate, owner);}

	public readonly elementType:elements.ElementType = elements.ElementType.enumerationLiteral;

	public appliedStereotypes: elements.Stereotype[] = [];

	public get enumeration(): elements.Enumeration {
		return this.modelDelegate.getEnumeration(this);
	}

	public isDeprecated: boolean = false;

	public name: string = '';

	public order: number = 0;

	public specification!: elements.ValueSpecification;

	public taggedValues: elements.TaggedValueSpecification[] = [];

	public visibility: elements.VisibilityKind | null = null;

	/**
	* Gets the value of the Specification property.
	* @returns {any} The default value (the type depending on the type of value), or null if no default
	* value can be determined.
	*/
	public getSpecificationValue(): any | null
	{
		return this.modelDelegate.getSpecificationValue(this);
	}

	public addAppliedStereotype(stereotype: elements.Stereotype): this
	{
		this.appliedStereotypes.push(stereotype);
		this.modelDelegate.onAppliedStereotypeAdded(this, stereotype);
		return this;
	}

	public addOwnedComment(properties: editable.CommentProperties): this
	{
		this.ownedComments.push(this.modelDelegate.createElement('comment', this, properties, null));
		return this;
	}

	public setSpecification(value: number): this;
	public setSpecification(value: string): this;
	public setSpecification(value: any): this
	{
		this.modelDelegate.setSpecification(this, value);
		return this;
	}
}

export class Enumeration extends Element implements elements.Enumeration, editable.EnumerationEditable {
	constructor(modelDelegate:ModelDelegate, owner: elements.Element | null) {super(modelDelegate, owner);}

	public readonly elementType:elements.ElementType = elements.ElementType.enumeration;

	public appliedStereotypes: elements.Stereotype[] = [];

	public baseType: elements.Type | null = null;

	public generalizations: elements.Generalization[] = [];

	public isAbstract: boolean = false;

	public isDeprecated: boolean = false;

	public isFinalSpecialization: boolean = false;

	public isInferred: boolean = false;

	public isLeaf: boolean = false;

	public name: string = '';

	public ownedAttributes: elements.Property[] = [];

	public ownedLiterals: elements.EnumerationLiteral[] = [];

	public ownedOperations: elements.Operation[] = [];

	public get package(): elements.Package {
		return this.modelDelegate.getPackage(this);
	}

	public taggedValues: elements.TaggedValueSpecification[] = [];

	public visibility: elements.VisibilityKind | null = null;

	/**
	* Returns both inherited and owned attributes.
	* @returns {elements.Property[]}
	*/
	public getAllAttributes(): elements.Property[]
	{
		return this.modelDelegate.getAllAttributes(this);
	}

	/**
	* Returns both inherited and owned operations. Any inherited operation that has the same signature
	* (having the same name and parameter type order) in an inheriting type is not included.
	* @returns {elements.Operation[]}
	*/
	public getAllOperations(): elements.Operation[]
	{
		return this.modelDelegate.getAllOperations(this);
	}

	/**
	* Returns all of the direct and indirect ancestors of a generalized Classifier, working outwards: more
	* specific classifiers will appear before more general classifiers.
	* @returns {elements.Classifier[]}
	*/
	public getAllParents(): elements.Classifier[]
	{
		return this.modelDelegate.getAllParents(this);
	}

	/**
	* Gets all classifiers of which this element is a direct or indirect general.
	* @returns {elements.Classifier[]}
	*/
	public getAllSpecializations(): elements.Classifier[]
	{
		return this.modelDelegate.getAllSpecializations(this);
	}

	/**
	* Gets the first direct generalization relationship of the element.
	* @returns {elements.Generalization}
	*/
	public getFirstGeneralization(): elements.Generalization | null
	{
		return this.modelDelegate.getFirstGeneralization(this);
	}

	/**
	* Gets the first classifier that is an immediate general of the current element.
	* @returns {elements.Classifier}
	*/
	public getFirstParent(): elements.Classifier | null
	{
		return this.modelDelegate.getFirstParent(this);
	}

	/**
	* Constructs a name from the names of the nesting packages. The name is constructed working inwards
	* from the package that is defined as namespace root up to but not including the PackageableElement
	* itself.
	* @param {string} separator The string to use to separate names. If not specified, a dot "." will be
	* used.
	* @returns {string} A single string with all the names separated.
	*/
	public getNamespaceName(separator?: string): string
	{
		return this.modelDelegate.getNamespaceName(this, separator);
	}

	/**
	* Gets all packages that contain this Package, working inwards from the top Package to the owning
	* package.
	* @returns {elements.Package[]} A collection of Packages.
	*/
	public getNestingPackages(): elements.Package[]
	{
		return this.modelDelegate.getNestingPackages(this);
	}

	/**
	* Gives all of the immediate ancestors of a generalized Classifier.
	* @returns {elements.Classifier[]}
	*/
	public getParents(): elements.Classifier[]
	{
		return this.modelDelegate.getParents(this);
	}

	/**
	* Constructs a name from the PackageableElement and the names of the nesting packages. The name is
	* constructed working inwards from the package that is defined as namespace root up to and including
	* the PackageableElement itself.
	* @param {string} separator The string to use to separate names. If not specified, a dot "." will be
	* used.
	* @returns {string} A single string with all the names separated.
	*/
	public getQualifiedName(separator?: string): string
	{
		return this.modelDelegate.getQualifiedName(this, separator);
	}

	/**
	* Gets all classifiers of which this classifier is a direct general.
	* @returns {elements.Classifier[]}
	*/
	public getSpecializations(): elements.Classifier[]
	{
		return this.modelDelegate.getSpecializations(this);
	}

	public addAppliedStereotype(stereotype: elements.Stereotype): this
	{
		this.appliedStereotypes.push(stereotype);
		this.modelDelegate.onAppliedStereotypeAdded(this, stereotype);
		return this;
	}

	public addOwnedComment(properties: editable.CommentProperties): this
	{
		this.ownedComments.push(this.modelDelegate.createElement('comment', this, properties, null));
		return this;
	}

	public addGeneralization(properties: editable.GeneralizationProperties, initFn?: (generalization: editable.GeneralizationEditable) => void): this
	{
		this.generalizations.push(this.modelDelegate.createElement('generalization', this, properties, initFn || null));
		return this;
	}

	public addOwnedAttribute(properties: editable.PropertyProperties, initFn?: (property: editable.PropertyEditable) => void): this
	{
		this.ownedAttributes.push(this.modelDelegate.createElement('property', this, properties, initFn || null));
		return this;
	}

	public addOwnedOperation(properties: editable.OperationProperties, initFn?: (operation: editable.OperationEditable) => void): this
	{
		this.ownedOperations.push(this.modelDelegate.createElement('operation', this, properties, initFn || null));
		return this;
	}

	public addOwnedLiteral(properties: editable.EnumerationLiteralProperties, initFn?: (enumerationLiteral: editable.EnumerationLiteralEditable) => void): this
	{
		this.ownedLiterals.push(this.modelDelegate.createElement('enumerationLiteral', this, properties, initFn || null));
		return this;
	}
}

export class DocumentReference implements elements.DocumentReference {

	public location!: elements.DocumentLocationKind;

	public name: string = '';

	public path: string = '';
}

export class Comment extends Element implements elements.Comment {
	constructor(modelDelegate:ModelDelegate, owner: elements.Element | null) {super(modelDelegate, owner);}

	public readonly elementType:elements.ElementType = elements.ElementType.comment;

	public appliedStereotypes: elements.Stereotype[] = [];

	public body: string = '';

	public taggedValues: elements.TaggedValueSpecification[] = [];
}

export class Association extends Element implements elements.Association, editable.AssociationEditable {
	constructor(modelDelegate:ModelDelegate, owner: elements.Element | null) {super(modelDelegate, owner);}

	public readonly elementType:elements.ElementType = elements.ElementType.association;

	public appliedStereotypes: elements.Stereotype[] = [];

	public generalizations: elements.Generalization[] = [];

	public isAbstract: boolean = false;

	public isDeprecated: boolean = false;

	public isFinalSpecialization: boolean = false;

	public isInferred: boolean = false;

	public isLeaf: boolean = false;

	public memberEnds: elements.Property[] = [];

	public name: string = '';

	public ownedEnds: elements.Property[] = [];

	public get package(): elements.Package {
		return this.modelDelegate.getPackage(this);
	}

	public taggedValues: elements.TaggedValueSpecification[] = [];

	public visibility: elements.VisibilityKind | null = null;

	/**
	* Returns all of the direct and indirect ancestors of a generalized Classifier, working outwards: more
	* specific classifiers will appear before more general classifiers.
	* @returns {elements.Classifier[]}
	*/
	public getAllParents(): elements.Classifier[]
	{
		return this.modelDelegate.getAllParents(this);
	}

	/**
	* Gets all classifiers of which this element is a direct or indirect general.
	* @returns {elements.Classifier[]}
	*/
	public getAllSpecializations(): elements.Classifier[]
	{
		return this.modelDelegate.getAllSpecializations(this);
	}

	/**
	* Gets the first direct generalization relationship of the element.
	* @returns {elements.Generalization}
	*/
	public getFirstGeneralization(): elements.Generalization | null
	{
		return this.modelDelegate.getFirstGeneralization(this);
	}

	/**
	* Gets the first classifier that is an immediate general of the current element.
	* @returns {elements.Classifier}
	*/
	public getFirstParent(): elements.Classifier | null
	{
		return this.modelDelegate.getFirstParent(this);
	}

	/**
	* Constructs a name from the names of the nesting packages. The name is constructed working inwards
	* from the package that is defined as namespace root up to but not including the PackageableElement
	* itself.
	* @param {string} separator The string to use to separate names. If not specified, a dot "." will be
	* used.
	* @returns {string} A single string with all the names separated.
	*/
	public getNamespaceName(separator?: string): string
	{
		return this.modelDelegate.getNamespaceName(this, separator);
	}

	/**
	* Gets all packages that contain this Package, working inwards from the top Package to the owning
	* package.
	* @returns {elements.Package[]} A collection of Packages.
	*/
	public getNestingPackages(): elements.Package[]
	{
		return this.modelDelegate.getNestingPackages(this);
	}

	/**
	* Gives all of the immediate ancestors of a generalized Classifier.
	* @returns {elements.Classifier[]}
	*/
	public getParents(): elements.Classifier[]
	{
		return this.modelDelegate.getParents(this);
	}

	/**
	* Constructs a name from the PackageableElement and the names of the nesting packages. The name is
	* constructed working inwards from the package that is defined as namespace root up to and including
	* the PackageableElement itself.
	* @param {string} separator The string to use to separate names. If not specified, a dot "." will be
	* used.
	* @returns {string} A single string with all the names separated.
	*/
	public getQualifiedName(separator?: string): string
	{
		return this.modelDelegate.getQualifiedName(this, separator);
	}

	/**
	* Gets all classifiers of which this classifier is a direct general.
	* @returns {elements.Classifier[]}
	*/
	public getSpecializations(): elements.Classifier[]
	{
		return this.modelDelegate.getSpecializations(this);
	}

	public addAppliedStereotype(stereotype: elements.Stereotype): this
	{
		this.appliedStereotypes.push(stereotype);
		this.modelDelegate.onAppliedStereotypeAdded(this, stereotype);
		return this;
	}

	public addOwnedComment(properties: editable.CommentProperties): this
	{
		this.ownedComments.push(this.modelDelegate.createElement('comment', this, properties, null));
		return this;
	}

	public addGeneralization(properties: editable.GeneralizationProperties, initFn?: (generalization: editable.GeneralizationEditable) => void): this
	{
		this.generalizations.push(this.modelDelegate.createElement('generalization', this, properties, initFn || null));
		return this;
	}

	public addMemberEnd(property: elements.Property): this
	{
		this.memberEnds.push(property);
		this.modelDelegate.onMemberEndAdded(this, property);
		return this;
	}

	public addOwnedEnd(properties: editable.PropertyProperties, initFn?: (property: editable.PropertyEditable) => void): this
	{
		this.ownedEnds.push(this.modelDelegate.createElement('property', this, properties, initFn || null));
		return this;
	}
}
