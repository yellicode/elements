/*
* Copyright (c) 2018 Yellicode
*
* This Source Code Form is subject to the terms of the Mozilla Public
* License, v. 2.0. If a copy of the MPL was not distributed with this
* file, You can obtain one at http://mozilla.org/MPL/2.0/.
*/

/**
* This code was generated by a tool.
* 
* Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
*/
import * as Interfaces from "./interfaces";
import {ModelDelegate} from "./model-delegate";

export class DocumentReference implements Interfaces.DocumentReference
{
	public path: string = '';
	public name: string = '';
	public location!: Interfaces.DocumentLocationKind;
}

export class StereotypeExtension implements Interfaces.StereotypeExtension
{
	public isRequired: boolean = false;
	public metaClass!: Interfaces.ElementType;
}

export class TaggedValueSpecification implements Interfaces.TaggedValueSpecification
{
	public definition!: Interfaces.Property;
	public specification!: Interfaces.ValueSpecification;
}

export abstract class Element implements Interfaces.Element
{
	constructor(protected modelDelegate:ModelDelegate, owner: Interfaces.Element | null)
	{
		this.owner = owner;
	}
	public abstract readonly elementType: Interfaces.ElementType;
	public id: string = '';
	public ownedComments: Interfaces.Comment[] = [];
	public readonly owner: Interfaces.Element | null = null;
	public appliedStereotypes: Interfaces.Stereotype[] = [];
	public taggedValues: Interfaces.TaggedValueSpecification[] = [];
	/**
	* Gets the text contents of the first comment in the element's owned comments, or an empty string if
	* the element has no comments.
	* @returns {string} The body string of the first comment. If the element has no comments, an empty
	* string is returned.
	*/
	public getFirstCommentBody(): string
	{
		return this.modelDelegate.getFirstCommentBody(this);
	}
}

export class Class extends Element implements Interfaces.Class
{
	constructor(modelDelegate:ModelDelegate, owner: Interfaces.Element | null) {super(modelDelegate, owner);}
	public readonly elementType:Interfaces.ElementType = Interfaces.ElementType.class;
	public isActive: boolean = false;
	public interfaceRealizations: Interfaces.InterfaceRealization[] = [];
	public isAbstract: boolean = false;
	public isFinalSpecialization: boolean = false;
	public generalizations: Interfaces.Generalization[] = [];
	public isInferred: boolean = false;
	public get package(): Interfaces.Package {
		return this.modelDelegate.getPackage(this);
	}
	public name: string = '';
	public visibility: Interfaces.VisibilityKind | null = null;
	public appliedStereotypes: Interfaces.Stereotype[] = [];
	public taggedValues: Interfaces.TaggedValueSpecification[] = [];
	public isLeaf: boolean = false;
	public ownedAttributes: Interfaces.Property[] = [];
	public ownedOperations: Interfaces.Operation[] = [];
	/**
	* Gets the superclasses of a Class, derived from its Generalizations.
	* @returns {Interfaces.Class[]}
	*/
	public getSuperClasses(): Interfaces.Class[]
	{
		return this.modelDelegate.getSuperClasses(this);
	}
	/**
	* Gets the first direct generalization relationship of the element.
	* @returns {Interfaces.Generalization}
	*/
	public getFirstGeneralization(): Interfaces.Generalization | null
	{
		return this.modelDelegate.getFirstGeneralization(this);
	}
	/**
	* Gets the first classifier that is an immediate general of the current element.
	* @returns {Interfaces.Classifier}
	*/
	public getFirstParent(): Interfaces.Classifier | null
	{
		return this.modelDelegate.getFirstParent(this);
	}
	/**
	* Gives all of the immediate ancestors of a generalized Classifier.
	* @returns {Interfaces.Classifier[]}
	*/
	public getParents(): Interfaces.Classifier[]
	{
		return this.modelDelegate.getParents(this);
	}
	/**
	* Returns all of the direct and indirect ancestors of a generalized Classifier, working outwards: more
	* specific classifiers will appear before more general classifiers.
	* @returns {Interfaces.Classifier[]}
	*/
	public getAllParents(): Interfaces.Classifier[]
	{
		return this.modelDelegate.getAllParents(this);
	}
	/**
	* Gets all classifiers of which this classifier is a direct general.
	* @returns {Interfaces.Classifier[]}
	*/
	public getSpecializations(): Interfaces.Classifier[]
	{
		return this.modelDelegate.getSpecializations(this);
	}
	/**
	* Gets all classifiers of which this element is a direct or indirect general.
	* @returns {Interfaces.Classifier[]}
	*/
	public getAllSpecializations(): Interfaces.Classifier[]
	{
		return this.modelDelegate.getAllSpecializations(this);
	}
	/**
	* Gets all packages that contain this Package, working inwards from the top Package to the owning
	* package.
	* @returns {Interfaces.Package[]} A collection of Packages.
	*/
	public getNestingPackages(): Interfaces.Package[]
	{
		return this.modelDelegate.getNestingPackages(this);
	}
	/**
	* Constructs a name from the names of the nesting packages. The name is constructed working inwards
	* from the package that is defined as namespace root up to but not including the PackageableElement
	* itself.
	* @param {string} separator The string to use to separate names. If not specified, a dot "." will be
	* used.
	* @returns {string} A single string with all the names separated.
	*/
	public getNamespaceName(separator?: string): string
	{
		return this.modelDelegate.getNamespaceName(this, separator);
	}
	/**
	* Constructs a name from the PackageableElement and the names of the nesting packages. The name is
	* constructed working inwards from the package that is defined as namespace root up to and including
	* the PackageableElement itself.
	* @param {string} separator The string to use to separate names. If not specified, a dot "." will be
	* used.
	* @returns {string} A single string with all the names separated.
	*/
	public getQualifiedName(separator?: string): string
	{
		return this.modelDelegate.getQualifiedName(this, separator);
	}
	/**
	* Returns both inherited and owned attributes.
	* @returns {Interfaces.Property[]}
	*/
	public getAllAttributes(): Interfaces.Property[]
	{
		return this.modelDelegate.getAllAttributes(this);
	}
	/**
	* Returns both inherited and owned operations. Any inherited operation that has the same signature
	* (having the same name and parameter type order) in an inheriting type is not included.
	* @returns {Interfaces.Operation[]}
	*/
	public getAllOperations(): Interfaces.Operation[]
	{
		return this.modelDelegate.getAllOperations(this);
	}
}

export class Stereotype extends Element implements Interfaces.Stereotype
{
	constructor(modelDelegate:ModelDelegate, owner: Interfaces.Element | null) {super(modelDelegate, owner);}
	public readonly elementType:Interfaces.ElementType = Interfaces.ElementType.stereotype;
	public safeName: string = '';
	public extends: Interfaces.StereotypeExtension[] = [];
	public isActive: boolean = false;
	public interfaceRealizations: Interfaces.InterfaceRealization[] = [];
	public isAbstract: boolean = false;
	public isFinalSpecialization: boolean = false;
	public generalizations: Interfaces.Generalization[] = [];
	public isInferred: boolean = false;
	public get package(): Interfaces.Package {
		return this.modelDelegate.getPackage(this);
	}
	public name: string = '';
	public visibility: Interfaces.VisibilityKind | null = null;
	public appliedStereotypes: Interfaces.Stereotype[] = [];
	public taggedValues: Interfaces.TaggedValueSpecification[] = [];
	public isLeaf: boolean = false;
	public ownedAttributes: Interfaces.Property[] = [];
	public ownedOperations: Interfaces.Operation[] = [];
	/**
	* Gets the superclasses of a Class, derived from its Generalizations.
	* @returns {Interfaces.Class[]}
	*/
	public getSuperClasses(): Interfaces.Class[]
	{
		return this.modelDelegate.getSuperClasses(this);
	}
	/**
	* Gets the first direct generalization relationship of the element.
	* @returns {Interfaces.Generalization}
	*/
	public getFirstGeneralization(): Interfaces.Generalization | null
	{
		return this.modelDelegate.getFirstGeneralization(this);
	}
	/**
	* Gets the first classifier that is an immediate general of the current element.
	* @returns {Interfaces.Classifier}
	*/
	public getFirstParent(): Interfaces.Classifier | null
	{
		return this.modelDelegate.getFirstParent(this);
	}
	/**
	* Gives all of the immediate ancestors of a generalized Classifier.
	* @returns {Interfaces.Classifier[]}
	*/
	public getParents(): Interfaces.Classifier[]
	{
		return this.modelDelegate.getParents(this);
	}
	/**
	* Returns all of the direct and indirect ancestors of a generalized Classifier, working outwards: more
	* specific classifiers will appear before more general classifiers.
	* @returns {Interfaces.Classifier[]}
	*/
	public getAllParents(): Interfaces.Classifier[]
	{
		return this.modelDelegate.getAllParents(this);
	}
	/**
	* Gets all classifiers of which this classifier is a direct general.
	* @returns {Interfaces.Classifier[]}
	*/
	public getSpecializations(): Interfaces.Classifier[]
	{
		return this.modelDelegate.getSpecializations(this);
	}
	/**
	* Gets all classifiers of which this element is a direct or indirect general.
	* @returns {Interfaces.Classifier[]}
	*/
	public getAllSpecializations(): Interfaces.Classifier[]
	{
		return this.modelDelegate.getAllSpecializations(this);
	}
	/**
	* Gets all packages that contain this Package, working inwards from the top Package to the owning
	* package.
	* @returns {Interfaces.Package[]} A collection of Packages.
	*/
	public getNestingPackages(): Interfaces.Package[]
	{
		return this.modelDelegate.getNestingPackages(this);
	}
	/**
	* Constructs a name from the names of the nesting packages. The name is constructed working inwards
	* from the package that is defined as namespace root up to but not including the PackageableElement
	* itself.
	* @param {string} separator The string to use to separate names. If not specified, a dot "." will be
	* used.
	* @returns {string} A single string with all the names separated.
	*/
	public getNamespaceName(separator?: string): string
	{
		return this.modelDelegate.getNamespaceName(this, separator);
	}
	/**
	* Constructs a name from the PackageableElement and the names of the nesting packages. The name is
	* constructed working inwards from the package that is defined as namespace root up to and including
	* the PackageableElement itself.
	* @param {string} separator The string to use to separate names. If not specified, a dot "." will be
	* used.
	* @returns {string} A single string with all the names separated.
	*/
	public getQualifiedName(separator?: string): string
	{
		return this.modelDelegate.getQualifiedName(this, separator);
	}
	/**
	* Returns both inherited and owned attributes.
	* @returns {Interfaces.Property[]}
	*/
	public getAllAttributes(): Interfaces.Property[]
	{
		return this.modelDelegate.getAllAttributes(this);
	}
	/**
	* Returns both inherited and owned operations. Any inherited operation that has the same signature
	* (having the same name and parameter type order) in an inheriting type is not included.
	* @returns {Interfaces.Operation[]}
	*/
	public getAllOperations(): Interfaces.Operation[]
	{
		return this.modelDelegate.getAllOperations(this);
	}
}

export class Package extends Element implements Interfaces.Package
{
	constructor(modelDelegate:ModelDelegate, owner: Interfaces.Element | null) {super(modelDelegate, owner);}
	public readonly elementType:Interfaces.ElementType = Interfaces.ElementType.package;
	public isNamespaceRoot: boolean = false;
	public packagedElements: Interfaces.PackageableElement[] = [];
	public appliedProfiles: Interfaces.Profile[] = [];
	public get package(): Interfaces.Package {
		return this.modelDelegate.getPackage(this);
	}
	public name: string = '';
	public visibility: Interfaces.VisibilityKind | null = null;
	public appliedStereotypes: Interfaces.Stereotype[] = [];
	public taggedValues: Interfaces.TaggedValueSpecification[] = [];
	/**
	* Gets all packages that are owned by this Package.
	* @returns {Interfaces.Package[]} A subset of PackagedElements.
	*/
	public getNestedPackages(): Interfaces.Package[]
	{
		return this.modelDelegate.getNestedPackages(this);
	}
	/**
	* Gets all classes that are owned by this Package.
	* @returns {Interfaces.Class[]} A subset of PackagedElements.
	*/
	public getClasses(): Interfaces.Class[]
	{
		return this.modelDelegate.getClasses(this);
	}
	/**
	* Gets all classes that are owned by this Package, including the ones owned by nested packages.
	* @returns {Interfaces.Class[]}
	*/
	public getAllClasses(): Interfaces.Class[]
	{
		return this.modelDelegate.getAllClasses(this);
	}
	/**
	* Gets all interfaces that are owned by this Package.
	* @returns {Interfaces.Interface[]} A subset of PackagedElements.
	*/
	public getInterfaces(): Interfaces.Interface[]
	{
		return this.modelDelegate.getInterfaces(this);
	}
	/**
	* Gets all interfaces that are owned by this Package, including the ones owned by nested packages.
	* @returns {Interfaces.Interface[]}
	*/
	public getAllInterfaces(): Interfaces.Interface[]
	{
		return this.modelDelegate.getAllInterfaces(this);
	}
	/**
	* Gets all data types that are owned by this Package.
	* @returns {Interfaces.DataType[]} A subset of PackagedElements.
	*/
	public getDataTypes(): Interfaces.DataType[]
	{
		return this.modelDelegate.getDataTypes(this);
	}
	/**
	* Gets all data types that are owned by this Package, including the ones owned by nested packages.
	* @returns {Interfaces.DataType[]}
	*/
	public getAllDataTypes(): Interfaces.DataType[]
	{
		return this.modelDelegate.getAllDataTypes(this);
	}
	/**
	* Gets all enumerations that are owned by this Package.
	* @returns {Interfaces.Enumeration[]} A subset of PackagedElements.
	*/
	public getEnumerations(): Interfaces.Enumeration[]
	{
		return this.modelDelegate.getEnumerations(this);
	}
	/**
	* Gets all enumerations that are owned by this Package, including the ones owned by nested packages.
	* @returns {Interfaces.Enumeration[]}
	*/
	public getAllEnumerations(): Interfaces.Enumeration[]
	{
		return this.modelDelegate.getAllEnumerations(this);
	}
	/**
	* Gets all types that are owned by this Package. This includes the following types of elements: Class,
	* Interface, DataType, PrimitiveType and Enumeration.
	* @returns {Interfaces.Classifier[]} A subset of PackagedElements.
	*/
	public getTypes(): Interfaces.Classifier[]
	{
		return this.modelDelegate.getTypes(this);
	}
	/**
	* Gets all enumerations that are owned by this Package, including the ones owned by nested packages.
	* This includes the following types of elements: Class, Interface, DataType, PrimitiveType and
	* Enumeration.
	* @returns {Interfaces.Classifier[]} A subset of PackagedElements.
	*/
	public getAllTypes(): Interfaces.Classifier[]
	{
		return this.modelDelegate.getAllTypes(this);
	}
	/**
	* Gets all packages that contain this Package, working inwards from the top Package to the owning
	* package.
	* @returns {Interfaces.Package[]} A collection of Packages.
	*/
	public getNestingPackages(): Interfaces.Package[]
	{
		return this.modelDelegate.getNestingPackages(this);
	}
	/**
	* Constructs a name from the names of the nesting packages. The name is constructed working inwards
	* from the package that is defined as namespace root up to but not including the PackageableElement
	* itself.
	* @param {string} separator The string to use to separate names. If not specified, a dot "." will be
	* used.
	* @returns {string} A single string with all the names separated.
	*/
	public getNamespaceName(separator?: string): string
	{
		return this.modelDelegate.getNamespaceName(this, separator);
	}
	/**
	* Constructs a name from the PackageableElement and the names of the nesting packages. The name is
	* constructed working inwards from the package that is defined as namespace root up to and including
	* the PackageableElement itself.
	* @param {string} separator The string to use to separate names. If not specified, a dot "." will be
	* used.
	* @returns {string} A single string with all the names separated.
	*/
	public getQualifiedName(separator?: string): string
	{
		return this.modelDelegate.getQualifiedName(this, separator);
	}
}

export class Profile extends Element implements Interfaces.Profile
{
	constructor(modelDelegate:ModelDelegate, owner: Interfaces.Element | null) {super(modelDelegate, owner);}
	public readonly elementType:Interfaces.ElementType = Interfaces.ElementType.profile;
	public safeName: string = '';
	public isNamespaceRoot: boolean = false;
	public packagedElements: Interfaces.PackageableElement[] = [];
	public appliedProfiles: Interfaces.Profile[] = [];
	public get package(): Interfaces.Package {
		return this.modelDelegate.getPackage(this);
	}
	public name: string = '';
	public visibility: Interfaces.VisibilityKind | null = null;
	public appliedStereotypes: Interfaces.Stereotype[] = [];
	public taggedValues: Interfaces.TaggedValueSpecification[] = [];
	/**
	* Gets all packages that are owned by this Package.
	* @returns {Interfaces.Package[]} A subset of PackagedElements.
	*/
	public getNestedPackages(): Interfaces.Package[]
	{
		return this.modelDelegate.getNestedPackages(this);
	}
	/**
	* Gets all classes that are owned by this Package.
	* @returns {Interfaces.Class[]} A subset of PackagedElements.
	*/
	public getClasses(): Interfaces.Class[]
	{
		return this.modelDelegate.getClasses(this);
	}
	/**
	* Gets all classes that are owned by this Package, including the ones owned by nested packages.
	* @returns {Interfaces.Class[]}
	*/
	public getAllClasses(): Interfaces.Class[]
	{
		return this.modelDelegate.getAllClasses(this);
	}
	/**
	* Gets all interfaces that are owned by this Package.
	* @returns {Interfaces.Interface[]} A subset of PackagedElements.
	*/
	public getInterfaces(): Interfaces.Interface[]
	{
		return this.modelDelegate.getInterfaces(this);
	}
	/**
	* Gets all interfaces that are owned by this Package, including the ones owned by nested packages.
	* @returns {Interfaces.Interface[]}
	*/
	public getAllInterfaces(): Interfaces.Interface[]
	{
		return this.modelDelegate.getAllInterfaces(this);
	}
	/**
	* Gets all data types that are owned by this Package.
	* @returns {Interfaces.DataType[]} A subset of PackagedElements.
	*/
	public getDataTypes(): Interfaces.DataType[]
	{
		return this.modelDelegate.getDataTypes(this);
	}
	/**
	* Gets all data types that are owned by this Package, including the ones owned by nested packages.
	* @returns {Interfaces.DataType[]}
	*/
	public getAllDataTypes(): Interfaces.DataType[]
	{
		return this.modelDelegate.getAllDataTypes(this);
	}
	/**
	* Gets all enumerations that are owned by this Package.
	* @returns {Interfaces.Enumeration[]} A subset of PackagedElements.
	*/
	public getEnumerations(): Interfaces.Enumeration[]
	{
		return this.modelDelegate.getEnumerations(this);
	}
	/**
	* Gets all enumerations that are owned by this Package, including the ones owned by nested packages.
	* @returns {Interfaces.Enumeration[]}
	*/
	public getAllEnumerations(): Interfaces.Enumeration[]
	{
		return this.modelDelegate.getAllEnumerations(this);
	}
	/**
	* Gets all types that are owned by this Package. This includes the following types of elements: Class,
	* Interface, DataType, PrimitiveType and Enumeration.
	* @returns {Interfaces.Classifier[]} A subset of PackagedElements.
	*/
	public getTypes(): Interfaces.Classifier[]
	{
		return this.modelDelegate.getTypes(this);
	}
	/**
	* Gets all enumerations that are owned by this Package, including the ones owned by nested packages.
	* This includes the following types of elements: Class, Interface, DataType, PrimitiveType and
	* Enumeration.
	* @returns {Interfaces.Classifier[]} A subset of PackagedElements.
	*/
	public getAllTypes(): Interfaces.Classifier[]
	{
		return this.modelDelegate.getAllTypes(this);
	}
	/**
	* Gets all packages that contain this Package, working inwards from the top Package to the owning
	* package.
	* @returns {Interfaces.Package[]} A collection of Packages.
	*/
	public getNestingPackages(): Interfaces.Package[]
	{
		return this.modelDelegate.getNestingPackages(this);
	}
	/**
	* Constructs a name from the names of the nesting packages. The name is constructed working inwards
	* from the package that is defined as namespace root up to but not including the PackageableElement
	* itself.
	* @param {string} separator The string to use to separate names. If not specified, a dot "." will be
	* used.
	* @returns {string} A single string with all the names separated.
	*/
	public getNamespaceName(separator?: string): string
	{
		return this.modelDelegate.getNamespaceName(this, separator);
	}
	/**
	* Constructs a name from the PackageableElement and the names of the nesting packages. The name is
	* constructed working inwards from the package that is defined as namespace root up to and including
	* the PackageableElement itself.
	* @param {string} separator The string to use to separate names. If not specified, a dot "." will be
	* used.
	* @returns {string} A single string with all the names separated.
	*/
	public getQualifiedName(separator?: string): string
	{
		return this.modelDelegate.getQualifiedName(this, separator);
	}
}

export class Property extends Element implements Interfaces.Property
{
	constructor(modelDelegate:ModelDelegate, owner: Interfaces.Element | null) {super(modelDelegate, owner);}
	public readonly elementType:Interfaces.ElementType = Interfaces.ElementType.property;
	public aggregation: Interfaces.AggregationKind = Interfaces.AggregationKind.none;
	public isDerived: boolean = false;
	public isDerivedUnion: boolean = false;
	public isID: boolean = false;
	public isNavigable: boolean = false;
	public get association(): Interfaces.Association | null {
		return this.modelDelegate.getAssociation(this);
	}
	public defaultValue: Interfaces.ValueSpecification | null = null;
	public isReadOnly: boolean = false;
	public isStatic: boolean = false;
	public isLeaf: boolean = false;
	public name: string = '';
	public visibility: Interfaces.VisibilityKind | null = null;
	public appliedStereotypes: Interfaces.Stereotype[] = [];
	public taggedValues: Interfaces.TaggedValueSpecification[] = [];
	public order: number = 0;
	public isOrdered: boolean = false;
	public isUnique: boolean = false;
	public get upper(): Interfaces.UnlimitedNatural | null {
		return this.modelDelegate.getUpper(this);
	}
	public get lower(): number | null {
		return this.modelDelegate.getLower(this);
	}
	public upperValue: Interfaces.ValueSpecification | null = null;
	public lowerValue: Interfaces.ValueSpecification | null = null;
	public type: Interfaces.Type | null = null;
	/**
	* Gets the value of the DefaultValue property.
	* @returns {any} The default value (the type depending on the type of value), or null if no default
	* value can be determined.
	*/
	public getDefault(): any | null
	{
		return this.modelDelegate.getDefault(this);
	}
	/**
	* The query isMultivalued() checks whether this multiplicity has an upper bound greater than one.
	* @returns {boolean}
	*/
	public isMultivalued(): boolean
	{
		return this.modelDelegate.isMultivalued(this);
	}
	/**
	* The query isOptional checks whether this multiplicity has a lower bound of 0 (0..n).
	* @returns {boolean}
	*/
	public isOptional(): boolean
	{
		return this.modelDelegate.isOptional(this);
	}
	/**
	* The query isOptionalAndSingleValued checks whether this multiplicity has a lower bound of 0 and an
	* upper bound of 1 (0..1).
	* @returns {boolean}
	*/
	public isOptionalAndSinglevalued(): boolean
	{
		return this.modelDelegate.isOptionalAndSinglevalued(this);
	}
	/**
	* The query isRequiredAndSinglevalued checks whether this multiplicity has a lower bound of 1 and an
	* upper bound of 1 (1..1).
	* @returns {boolean}
	*/
	public isRequiredAndSinglevalued(): boolean
	{
		return this.modelDelegate.isRequiredAndSinglevalued(this);
	}
	/**
	* The query lowerBound() returns the lower bound of the multiplicity as an integer, which is the
	* integerValue of lowerValue, if this is given, and 1 otherwise.
	* @returns {number}
	*/
	public getLowerBound(): number
	{
		return this.modelDelegate.getLowerBound(this);
	}
	/**
	* The query upperBound() returns the upper bound of the multiplicity for a bounded multiplicity as an
	* unlimited natural, which is the unlimitedNaturalValue of upperValue, if given, and 1, otherwise.
	* @returns {Interfaces.UnlimitedNatural}
	*/
	public getUpperBound(): Interfaces.UnlimitedNatural
	{
		return this.modelDelegate.getUpperBound(this);
	}
	/**
	* Gets the name of the typed element's type.
	* @returns {string} The type name, or an empty string if the element has no type.
	*/
	public getTypeName(): string
	{
		return this.modelDelegate.getTypeName(this);
	}
}

export class DataType extends Element implements Interfaces.DataType
{
	constructor(modelDelegate:ModelDelegate, owner: Interfaces.Element | null) {super(modelDelegate, owner);}
	public readonly elementType:Interfaces.ElementType = Interfaces.ElementType.dataType;
	public ownedAttributes: Interfaces.Property[] = [];
	public ownedOperations: Interfaces.Operation[] = [];
	public isAbstract: boolean = false;
	public isFinalSpecialization: boolean = false;
	public generalizations: Interfaces.Generalization[] = [];
	public isInferred: boolean = false;
	public get package(): Interfaces.Package {
		return this.modelDelegate.getPackage(this);
	}
	public name: string = '';
	public visibility: Interfaces.VisibilityKind | null = null;
	public appliedStereotypes: Interfaces.Stereotype[] = [];
	public taggedValues: Interfaces.TaggedValueSpecification[] = [];
	public isLeaf: boolean = false;
	/**
	* Returns both inherited and owned attributes.
	* @returns {Interfaces.Property[]}
	*/
	public getAllAttributes(): Interfaces.Property[]
	{
		return this.modelDelegate.getAllAttributes(this);
	}
	/**
	* Returns both inherited and owned operations. Any inherited operation that has the same signature
	* (having the same name and parameter type order) in an inheriting type is not included.
	* @returns {Interfaces.Operation[]}
	*/
	public getAllOperations(): Interfaces.Operation[]
	{
		return this.modelDelegate.getAllOperations(this);
	}
	/**
	* Gets the first direct generalization relationship of the element.
	* @returns {Interfaces.Generalization}
	*/
	public getFirstGeneralization(): Interfaces.Generalization | null
	{
		return this.modelDelegate.getFirstGeneralization(this);
	}
	/**
	* Gets the first classifier that is an immediate general of the current element.
	* @returns {Interfaces.Classifier}
	*/
	public getFirstParent(): Interfaces.Classifier | null
	{
		return this.modelDelegate.getFirstParent(this);
	}
	/**
	* Gives all of the immediate ancestors of a generalized Classifier.
	* @returns {Interfaces.Classifier[]}
	*/
	public getParents(): Interfaces.Classifier[]
	{
		return this.modelDelegate.getParents(this);
	}
	/**
	* Returns all of the direct and indirect ancestors of a generalized Classifier, working outwards: more
	* specific classifiers will appear before more general classifiers.
	* @returns {Interfaces.Classifier[]}
	*/
	public getAllParents(): Interfaces.Classifier[]
	{
		return this.modelDelegate.getAllParents(this);
	}
	/**
	* Gets all classifiers of which this classifier is a direct general.
	* @returns {Interfaces.Classifier[]}
	*/
	public getSpecializations(): Interfaces.Classifier[]
	{
		return this.modelDelegate.getSpecializations(this);
	}
	/**
	* Gets all classifiers of which this element is a direct or indirect general.
	* @returns {Interfaces.Classifier[]}
	*/
	public getAllSpecializations(): Interfaces.Classifier[]
	{
		return this.modelDelegate.getAllSpecializations(this);
	}
	/**
	* Gets all packages that contain this Package, working inwards from the top Package to the owning
	* package.
	* @returns {Interfaces.Package[]} A collection of Packages.
	*/
	public getNestingPackages(): Interfaces.Package[]
	{
		return this.modelDelegate.getNestingPackages(this);
	}
	/**
	* Constructs a name from the names of the nesting packages. The name is constructed working inwards
	* from the package that is defined as namespace root up to but not including the PackageableElement
	* itself.
	* @param {string} separator The string to use to separate names. If not specified, a dot "." will be
	* used.
	* @returns {string} A single string with all the names separated.
	*/
	public getNamespaceName(separator?: string): string
	{
		return this.modelDelegate.getNamespaceName(this, separator);
	}
	/**
	* Constructs a name from the PackageableElement and the names of the nesting packages. The name is
	* constructed working inwards from the package that is defined as namespace root up to and including
	* the PackageableElement itself.
	* @param {string} separator The string to use to separate names. If not specified, a dot "." will be
	* used.
	* @returns {string} A single string with all the names separated.
	*/
	public getQualifiedName(separator?: string): string
	{
		return this.modelDelegate.getQualifiedName(this, separator);
	}
}

export class PrimitiveType extends Element implements Interfaces.PrimitiveType
{
	constructor(modelDelegate:ModelDelegate, owner: Interfaces.Element | null) {super(modelDelegate, owner);}
	public readonly elementType:Interfaces.ElementType = Interfaces.ElementType.primitiveType;
	public ownedAttributes: Interfaces.Property[] = [];
	public ownedOperations: Interfaces.Operation[] = [];
	public isAbstract: boolean = false;
	public isFinalSpecialization: boolean = false;
	public generalizations: Interfaces.Generalization[] = [];
	public isInferred: boolean = false;
	public get package(): Interfaces.Package {
		return this.modelDelegate.getPackage(this);
	}
	public name: string = '';
	public visibility: Interfaces.VisibilityKind | null = null;
	public appliedStereotypes: Interfaces.Stereotype[] = [];
	public taggedValues: Interfaces.TaggedValueSpecification[] = [];
	public isLeaf: boolean = false;
	/**
	* Returns both inherited and owned attributes.
	* @returns {Interfaces.Property[]}
	*/
	public getAllAttributes(): Interfaces.Property[]
	{
		return this.modelDelegate.getAllAttributes(this);
	}
	/**
	* Returns both inherited and owned operations. Any inherited operation that has the same signature
	* (having the same name and parameter type order) in an inheriting type is not included.
	* @returns {Interfaces.Operation[]}
	*/
	public getAllOperations(): Interfaces.Operation[]
	{
		return this.modelDelegate.getAllOperations(this);
	}
	/**
	* Gets the first direct generalization relationship of the element.
	* @returns {Interfaces.Generalization}
	*/
	public getFirstGeneralization(): Interfaces.Generalization | null
	{
		return this.modelDelegate.getFirstGeneralization(this);
	}
	/**
	* Gets the first classifier that is an immediate general of the current element.
	* @returns {Interfaces.Classifier}
	*/
	public getFirstParent(): Interfaces.Classifier | null
	{
		return this.modelDelegate.getFirstParent(this);
	}
	/**
	* Gives all of the immediate ancestors of a generalized Classifier.
	* @returns {Interfaces.Classifier[]}
	*/
	public getParents(): Interfaces.Classifier[]
	{
		return this.modelDelegate.getParents(this);
	}
	/**
	* Returns all of the direct and indirect ancestors of a generalized Classifier, working outwards: more
	* specific classifiers will appear before more general classifiers.
	* @returns {Interfaces.Classifier[]}
	*/
	public getAllParents(): Interfaces.Classifier[]
	{
		return this.modelDelegate.getAllParents(this);
	}
	/**
	* Gets all classifiers of which this classifier is a direct general.
	* @returns {Interfaces.Classifier[]}
	*/
	public getSpecializations(): Interfaces.Classifier[]
	{
		return this.modelDelegate.getSpecializations(this);
	}
	/**
	* Gets all classifiers of which this element is a direct or indirect general.
	* @returns {Interfaces.Classifier[]}
	*/
	public getAllSpecializations(): Interfaces.Classifier[]
	{
		return this.modelDelegate.getAllSpecializations(this);
	}
	/**
	* Gets all packages that contain this Package, working inwards from the top Package to the owning
	* package.
	* @returns {Interfaces.Package[]} A collection of Packages.
	*/
	public getNestingPackages(): Interfaces.Package[]
	{
		return this.modelDelegate.getNestingPackages(this);
	}
	/**
	* Constructs a name from the names of the nesting packages. The name is constructed working inwards
	* from the package that is defined as namespace root up to but not including the PackageableElement
	* itself.
	* @param {string} separator The string to use to separate names. If not specified, a dot "." will be
	* used.
	* @returns {string} A single string with all the names separated.
	*/
	public getNamespaceName(separator?: string): string
	{
		return this.modelDelegate.getNamespaceName(this, separator);
	}
	/**
	* Constructs a name from the PackageableElement and the names of the nesting packages. The name is
	* constructed working inwards from the package that is defined as namespace root up to and including
	* the PackageableElement itself.
	* @param {string} separator The string to use to separate names. If not specified, a dot "." will be
	* used.
	* @returns {string} A single string with all the names separated.
	*/
	public getQualifiedName(separator?: string): string
	{
		return this.modelDelegate.getQualifiedName(this, separator);
	}
}

export class Parameter extends Element implements Interfaces.Parameter
{
	constructor(modelDelegate:ModelDelegate, owner: Interfaces.Element | null) {super(modelDelegate, owner);}
	public readonly elementType:Interfaces.ElementType = Interfaces.ElementType.parameter;
	public direction: Interfaces.ParameterDirectionKind = Interfaces.ParameterDirectionKind.in;
	public isException: boolean = false;
	public isStream: boolean = false;
	public defaultValue: Interfaces.ValueSpecification | null = null;
	public type: Interfaces.Type | null = null;
	public name: string = '';
	public visibility: Interfaces.VisibilityKind | null = null;
	public appliedStereotypes: Interfaces.Stereotype[] = [];
	public taggedValues: Interfaces.TaggedValueSpecification[] = [];
	public isOrdered: boolean = false;
	public isUnique: boolean = false;
	public get upper(): Interfaces.UnlimitedNatural | null {
		return this.modelDelegate.getUpper(this);
	}
	public get lower(): number | null {
		return this.modelDelegate.getLower(this);
	}
	public upperValue: Interfaces.ValueSpecification | null = null;
	public lowerValue: Interfaces.ValueSpecification | null = null;
	public order: number = 0;
	/**
	* Gets the value of the DefaultValue property.
	* @returns {any} The default value (the type depending on the type of value), or null if no default
	* value can be determined.
	*/
	public getDefault(): any | null
	{
		return this.modelDelegate.getDefault(this);
	}
	/**
	* Gets the name of the typed element's type.
	* @returns {string} The type name, or an empty string if the element has no type.
	*/
	public getTypeName(): string
	{
		return this.modelDelegate.getTypeName(this);
	}
	/**
	* The query isMultivalued() checks whether this multiplicity has an upper bound greater than one.
	* @returns {boolean}
	*/
	public isMultivalued(): boolean
	{
		return this.modelDelegate.isMultivalued(this);
	}
	/**
	* The query isOptional checks whether this multiplicity has a lower bound of 0 (0..n).
	* @returns {boolean}
	*/
	public isOptional(): boolean
	{
		return this.modelDelegate.isOptional(this);
	}
	/**
	* The query isOptionalAndSingleValued checks whether this multiplicity has a lower bound of 0 and an
	* upper bound of 1 (0..1).
	* @returns {boolean}
	*/
	public isOptionalAndSinglevalued(): boolean
	{
		return this.modelDelegate.isOptionalAndSinglevalued(this);
	}
	/**
	* The query isRequiredAndSinglevalued checks whether this multiplicity has a lower bound of 1 and an
	* upper bound of 1 (1..1).
	* @returns {boolean}
	*/
	public isRequiredAndSinglevalued(): boolean
	{
		return this.modelDelegate.isRequiredAndSinglevalued(this);
	}
	/**
	* The query lowerBound() returns the lower bound of the multiplicity as an integer, which is the
	* integerValue of lowerValue, if this is given, and 1 otherwise.
	* @returns {number}
	*/
	public getLowerBound(): number
	{
		return this.modelDelegate.getLowerBound(this);
	}
	/**
	* The query upperBound() returns the upper bound of the multiplicity for a bounded multiplicity as an
	* unlimited natural, which is the unlimitedNaturalValue of upperValue, if given, and 1, otherwise.
	* @returns {Interfaces.UnlimitedNatural}
	*/
	public getUpperBound(): Interfaces.UnlimitedNatural
	{
		return this.modelDelegate.getUpperBound(this);
	}
}

export class Operation extends Element implements Interfaces.Operation
{
	constructor(modelDelegate:ModelDelegate, owner: Interfaces.Element | null) {super(modelDelegate, owner);}
	public readonly elementType:Interfaces.ElementType = Interfaces.ElementType.operation;
	public isQuery: boolean = false;
	public isConstructor: boolean = false;
	public get upper(): Interfaces.UnlimitedNatural | null {
		return this.modelDelegate.getUpper(this);
	}
	public get lower(): number | null {
		return this.modelDelegate.getLower(this);
	}
	public isAbstract: boolean = false;
	public ownedParameters: Interfaces.Parameter[] = [];
	public isStatic: boolean = false;
	public isLeaf: boolean = false;
	public name: string = '';
	public visibility: Interfaces.VisibilityKind | null = null;
	public appliedStereotypes: Interfaces.Stereotype[] = [];
	public taggedValues: Interfaces.TaggedValueSpecification[] = [];
	public order: number = 0;
	/**
	* Returns the ownedParameters with direction in and inout.
	* @returns {Interfaces.Parameter[]}
	*/
	public getInputParameters(): Interfaces.Parameter[]
	{
		return this.modelDelegate.getInputParameters(this);
	}
	/**
	* Returns the ownedParameters with direction out, inout, or return.
	* @returns {Interfaces.Parameter[]}
	*/
	public getOutputParameters(): Interfaces.Parameter[]
	{
		return this.modelDelegate.getOutputParameters(this);
	}
	/**
	* The query isMultivalued() checks whether the return parameter has an upper bound greater than one.
	* @returns {boolean}
	*/
	public isMultivalued(): boolean
	{
		return this.modelDelegate.isMultivalued(this);
	}
	/**
	* The query isOptional checks whether he return parameter has a lower bound of 0 (0..n).
	* @returns {boolean}
	*/
	public isOptional(): boolean
	{
		return this.modelDelegate.isOptional(this);
	}
	/**
	* The query isOptional checks whether he return parameter has a lower bound of 0 and an upper bound of
	* 1 (0..1).
	* @returns {boolean}
	*/
	public isOptionalAndSinglevalued(): boolean
	{
		return this.modelDelegate.isOptionalAndSinglevalued(this);
	}
	/**
	* Gets the type of the operation's return parameter, if it has any.
	* @returns {Interfaces.Type}
	*/
	public getReturnType(): Interfaces.Type | null
	{
		return this.modelDelegate.getReturnType(this);
	}
	/**
	* Gets the operation's return parameter, if it has one.
	* @returns {Interfaces.Parameter}
	*/
	public getReturnParameter(): Interfaces.Parameter | null
	{
		return this.modelDelegate.getReturnParameter(this);
	}
	/**
	* The query lowerBound() returns the lower bound of the return parameter as an integer, which is the
	* integerValue of lowerValue, if this is given, and 1 otherwise. This information is derived from the
	* return result for this Operation.
	* @returns {number}
	*/
	public getLowerBound(): number
	{
		return this.modelDelegate.getLowerBound(this);
	}
	/**
	* The query upperBound() returns the upper bound of the return parameter for a bounded multiplicity as
	* an unlimited natural, which is the unlimitedNaturalValue of upperValue, if given, and 1, otherwise.
	* This information is derived from the return result for this Operation.
	* @returns {Interfaces.UnlimitedNatural}
	*/
	public getUpperBound(): Interfaces.UnlimitedNatural
	{
		return this.modelDelegate.getUpperBound(this);
	}
}

export class Model extends Element implements Interfaces.Model
{
	constructor(modelDelegate:ModelDelegate, owner: Interfaces.Element | null) {super(modelDelegate, owner);}
	public readonly elementType:Interfaces.ElementType = Interfaces.ElementType.model;
	public isNamespaceRoot: boolean = false;
	public packagedElements: Interfaces.PackageableElement[] = [];
	public appliedProfiles: Interfaces.Profile[] = [];
	public get package(): Interfaces.Package {
		return this.modelDelegate.getPackage(this);
	}
	public name: string = '';
	public visibility: Interfaces.VisibilityKind | null = null;
	public appliedStereotypes: Interfaces.Stereotype[] = [];
	public taggedValues: Interfaces.TaggedValueSpecification[] = [];
	/**
	* Gets all packages that are owned by this Package.
	* @returns {Interfaces.Package[]} A subset of PackagedElements.
	*/
	public getNestedPackages(): Interfaces.Package[]
	{
		return this.modelDelegate.getNestedPackages(this);
	}
	/**
	* Gets all classes that are owned by this Package.
	* @returns {Interfaces.Class[]} A subset of PackagedElements.
	*/
	public getClasses(): Interfaces.Class[]
	{
		return this.modelDelegate.getClasses(this);
	}
	/**
	* Gets all classes that are owned by this Package, including the ones owned by nested packages.
	* @returns {Interfaces.Class[]}
	*/
	public getAllClasses(): Interfaces.Class[]
	{
		return this.modelDelegate.getAllClasses(this);
	}
	/**
	* Gets all interfaces that are owned by this Package.
	* @returns {Interfaces.Interface[]} A subset of PackagedElements.
	*/
	public getInterfaces(): Interfaces.Interface[]
	{
		return this.modelDelegate.getInterfaces(this);
	}
	/**
	* Gets all interfaces that are owned by this Package, including the ones owned by nested packages.
	* @returns {Interfaces.Interface[]}
	*/
	public getAllInterfaces(): Interfaces.Interface[]
	{
		return this.modelDelegate.getAllInterfaces(this);
	}
	/**
	* Gets all data types that are owned by this Package.
	* @returns {Interfaces.DataType[]} A subset of PackagedElements.
	*/
	public getDataTypes(): Interfaces.DataType[]
	{
		return this.modelDelegate.getDataTypes(this);
	}
	/**
	* Gets all data types that are owned by this Package, including the ones owned by nested packages.
	* @returns {Interfaces.DataType[]}
	*/
	public getAllDataTypes(): Interfaces.DataType[]
	{
		return this.modelDelegate.getAllDataTypes(this);
	}
	/**
	* Gets all enumerations that are owned by this Package.
	* @returns {Interfaces.Enumeration[]} A subset of PackagedElements.
	*/
	public getEnumerations(): Interfaces.Enumeration[]
	{
		return this.modelDelegate.getEnumerations(this);
	}
	/**
	* Gets all enumerations that are owned by this Package, including the ones owned by nested packages.
	* @returns {Interfaces.Enumeration[]}
	*/
	public getAllEnumerations(): Interfaces.Enumeration[]
	{
		return this.modelDelegate.getAllEnumerations(this);
	}
	/**
	* Gets all types that are owned by this Package. This includes the following types of elements: Class,
	* Interface, DataType, PrimitiveType and Enumeration.
	* @returns {Interfaces.Classifier[]} A subset of PackagedElements.
	*/
	public getTypes(): Interfaces.Classifier[]
	{
		return this.modelDelegate.getTypes(this);
	}
	/**
	* Gets all enumerations that are owned by this Package, including the ones owned by nested packages.
	* This includes the following types of elements: Class, Interface, DataType, PrimitiveType and
	* Enumeration.
	* @returns {Interfaces.Classifier[]} A subset of PackagedElements.
	*/
	public getAllTypes(): Interfaces.Classifier[]
	{
		return this.modelDelegate.getAllTypes(this);
	}
	/**
	* Gets all packages that contain this Package, working inwards from the top Package to the owning
	* package.
	* @returns {Interfaces.Package[]} A collection of Packages.
	*/
	public getNestingPackages(): Interfaces.Package[]
	{
		return this.modelDelegate.getNestingPackages(this);
	}
	/**
	* Constructs a name from the names of the nesting packages. The name is constructed working inwards
	* from the package that is defined as namespace root up to but not including the PackageableElement
	* itself.
	* @param {string} separator The string to use to separate names. If not specified, a dot "." will be
	* used.
	* @returns {string} A single string with all the names separated.
	*/
	public getNamespaceName(separator?: string): string
	{
		return this.modelDelegate.getNamespaceName(this, separator);
	}
	/**
	* Constructs a name from the PackageableElement and the names of the nesting packages. The name is
	* constructed working inwards from the package that is defined as namespace root up to and including
	* the PackageableElement itself.
	* @param {string} separator The string to use to separate names. If not specified, a dot "." will be
	* used.
	* @returns {string} A single string with all the names separated.
	*/
	public getQualifiedName(separator?: string): string
	{
		return this.modelDelegate.getQualifiedName(this, separator);
	}
}

export class LiteralUnlimitedNatural extends Element implements Interfaces.LiteralUnlimitedNatural
{
	constructor(modelDelegate:ModelDelegate, owner: Interfaces.Element | null) {super(modelDelegate, owner);}
	public readonly elementType:Interfaces.ElementType = Interfaces.ElementType.literalUnlimitedNatural;
	public value!: Interfaces.UnlimitedNatural;
	public type: Interfaces.Type | null = null;
	public name: string = '';
	public visibility: Interfaces.VisibilityKind | null = null;
	public appliedStereotypes: Interfaces.Stereotype[] = [];
	public taggedValues: Interfaces.TaggedValueSpecification[] = [];
	/**
	* Gets underlying value of the ValueSpecification. The type depends on the type of ValueSpecification.
	* @returns {any} The underlying value of the ValueSpecification. The type depends on the type of
	* ValueSpecification.
	*/
	public getValue(): any | null
	{
		return this.modelDelegate.getValue(this);
	}
	/**
	* Gets the string representation of the value.
	* @returns {string}
	*/
	public getStringValue(): string
	{
		return this.modelDelegate.getStringValue(this);
	}
	/**
	* Gets the name of the typed element's type.
	* @returns {string} The type name, or an empty string if the element has no type.
	*/
	public getTypeName(): string
	{
		return this.modelDelegate.getTypeName(this);
	}
}

export class LiteralString extends Element implements Interfaces.LiteralString
{
	constructor(modelDelegate:ModelDelegate, owner: Interfaces.Element | null) {super(modelDelegate, owner);}
	public readonly elementType:Interfaces.ElementType = Interfaces.ElementType.literalString;
	public value: string = '';
	public type: Interfaces.Type | null = null;
	public name: string = '';
	public visibility: Interfaces.VisibilityKind | null = null;
	public appliedStereotypes: Interfaces.Stereotype[] = [];
	public taggedValues: Interfaces.TaggedValueSpecification[] = [];
	/**
	* Gets underlying value of the ValueSpecification. The type depends on the type of ValueSpecification.
	* @returns {any} The underlying value of the ValueSpecification. The type depends on the type of
	* ValueSpecification.
	*/
	public getValue(): any | null
	{
		return this.modelDelegate.getValue(this);
	}
	/**
	* Gets the string representation of the value.
	* @returns {string}
	*/
	public getStringValue(): string
	{
		return this.modelDelegate.getStringValue(this);
	}
	/**
	* Gets the name of the typed element's type.
	* @returns {string} The type name, or an empty string if the element has no type.
	*/
	public getTypeName(): string
	{
		return this.modelDelegate.getTypeName(this);
	}
}

export class LiteralReal extends Element implements Interfaces.LiteralReal
{
	constructor(modelDelegate:ModelDelegate, owner: Interfaces.Element | null) {super(modelDelegate, owner);}
	public readonly elementType:Interfaces.ElementType = Interfaces.ElementType.literalReal;
	public value: number = 0;
	public type: Interfaces.Type | null = null;
	public name: string = '';
	public visibility: Interfaces.VisibilityKind | null = null;
	public appliedStereotypes: Interfaces.Stereotype[] = [];
	public taggedValues: Interfaces.TaggedValueSpecification[] = [];
	/**
	* Gets underlying value of the ValueSpecification. The type depends on the type of ValueSpecification.
	* @returns {any} The underlying value of the ValueSpecification. The type depends on the type of
	* ValueSpecification.
	*/
	public getValue(): any | null
	{
		return this.modelDelegate.getValue(this);
	}
	/**
	* Gets the string representation of the value.
	* @returns {string}
	*/
	public getStringValue(): string
	{
		return this.modelDelegate.getStringValue(this);
	}
	/**
	* Gets the name of the typed element's type.
	* @returns {string} The type name, or an empty string if the element has no type.
	*/
	public getTypeName(): string
	{
		return this.modelDelegate.getTypeName(this);
	}
}

export class LiteralNull extends Element implements Interfaces.LiteralNull
{
	constructor(modelDelegate:ModelDelegate, owner: Interfaces.Element | null) {super(modelDelegate, owner);}
	public readonly elementType:Interfaces.ElementType = Interfaces.ElementType.literalNull;
	public type: Interfaces.Type | null = null;
	public name: string = '';
	public visibility: Interfaces.VisibilityKind | null = null;
	public appliedStereotypes: Interfaces.Stereotype[] = [];
	public taggedValues: Interfaces.TaggedValueSpecification[] = [];
	/**
	* Gets underlying value of the ValueSpecification. The type depends on the type of ValueSpecification.
	* @returns {any} The underlying value of the ValueSpecification. The type depends on the type of
	* ValueSpecification.
	*/
	public getValue(): any | null
	{
		return this.modelDelegate.getValue(this);
	}
	/**
	* Gets the string representation of the value.
	* @returns {string}
	*/
	public getStringValue(): string
	{
		return this.modelDelegate.getStringValue(this);
	}
	/**
	* Gets the name of the typed element's type.
	* @returns {string} The type name, or an empty string if the element has no type.
	*/
	public getTypeName(): string
	{
		return this.modelDelegate.getTypeName(this);
	}
}

export class LiteralInteger extends Element implements Interfaces.LiteralInteger
{
	constructor(modelDelegate:ModelDelegate, owner: Interfaces.Element | null) {super(modelDelegate, owner);}
	public readonly elementType:Interfaces.ElementType = Interfaces.ElementType.literalInteger;
	public value: number = 0;
	public type: Interfaces.Type | null = null;
	public name: string = '';
	public visibility: Interfaces.VisibilityKind | null = null;
	public appliedStereotypes: Interfaces.Stereotype[] = [];
	public taggedValues: Interfaces.TaggedValueSpecification[] = [];
	/**
	* Gets underlying value of the ValueSpecification. The type depends on the type of ValueSpecification.
	* @returns {any} The underlying value of the ValueSpecification. The type depends on the type of
	* ValueSpecification.
	*/
	public getValue(): any | null
	{
		return this.modelDelegate.getValue(this);
	}
	/**
	* Gets the string representation of the value.
	* @returns {string}
	*/
	public getStringValue(): string
	{
		return this.modelDelegate.getStringValue(this);
	}
	/**
	* Gets the name of the typed element's type.
	* @returns {string} The type name, or an empty string if the element has no type.
	*/
	public getTypeName(): string
	{
		return this.modelDelegate.getTypeName(this);
	}
}

export class LiteralBoolean extends Element implements Interfaces.LiteralBoolean
{
	constructor(modelDelegate:ModelDelegate, owner: Interfaces.Element | null) {super(modelDelegate, owner);}
	public readonly elementType:Interfaces.ElementType = Interfaces.ElementType.literalBoolean;
	public value: boolean = false;
	public type: Interfaces.Type | null = null;
	public name: string = '';
	public visibility: Interfaces.VisibilityKind | null = null;
	public appliedStereotypes: Interfaces.Stereotype[] = [];
	public taggedValues: Interfaces.TaggedValueSpecification[] = [];
	/**
	* Gets underlying value of the ValueSpecification. The type depends on the type of ValueSpecification.
	* @returns {any} The underlying value of the ValueSpecification. The type depends on the type of
	* ValueSpecification.
	*/
	public getValue(): any | null
	{
		return this.modelDelegate.getValue(this);
	}
	/**
	* Gets the string representation of the value.
	* @returns {string}
	*/
	public getStringValue(): string
	{
		return this.modelDelegate.getStringValue(this);
	}
	/**
	* Gets the name of the typed element's type.
	* @returns {string} The type name, or an empty string if the element has no type.
	*/
	public getTypeName(): string
	{
		return this.modelDelegate.getTypeName(this);
	}
}

export class InterfaceRealization extends Element implements Interfaces.InterfaceRealization
{
	constructor(modelDelegate:ModelDelegate, owner: Interfaces.Element | null) {super(modelDelegate, owner);}
	public readonly elementType:Interfaces.ElementType = Interfaces.ElementType.interfaceRealization;
	public contract!: Interfaces.Interface;
	public appliedStereotypes: Interfaces.Stereotype[] = [];
	public taggedValues: Interfaces.TaggedValueSpecification[] = [];
}

export class Interface extends Element implements Interfaces.Interface
{
	constructor(modelDelegate:ModelDelegate, owner: Interfaces.Element | null) {super(modelDelegate, owner);}
	public readonly elementType:Interfaces.ElementType = Interfaces.ElementType.interface;
	public ownedAttributes: Interfaces.Property[] = [];
	public ownedOperations: Interfaces.Operation[] = [];
	public isAbstract: boolean = false;
	public isFinalSpecialization: boolean = false;
	public generalizations: Interfaces.Generalization[] = [];
	public isInferred: boolean = false;
	public get package(): Interfaces.Package {
		return this.modelDelegate.getPackage(this);
	}
	public name: string = '';
	public visibility: Interfaces.VisibilityKind | null = null;
	public appliedStereotypes: Interfaces.Stereotype[] = [];
	public taggedValues: Interfaces.TaggedValueSpecification[] = [];
	public isLeaf: boolean = false;
	/**
	* Returns both inherited and owned attributes.
	* @returns {Interfaces.Property[]}
	*/
	public getAllAttributes(): Interfaces.Property[]
	{
		return this.modelDelegate.getAllAttributes(this);
	}
	/**
	* Returns both inherited and owned operations. Any inherited operation that has the same signature
	* (having the same name and parameter type order) in an inheriting type is not included.
	* @returns {Interfaces.Operation[]}
	*/
	public getAllOperations(): Interfaces.Operation[]
	{
		return this.modelDelegate.getAllOperations(this);
	}
	/**
	* Gets the first direct generalization relationship of the element.
	* @returns {Interfaces.Generalization}
	*/
	public getFirstGeneralization(): Interfaces.Generalization | null
	{
		return this.modelDelegate.getFirstGeneralization(this);
	}
	/**
	* Gets the first classifier that is an immediate general of the current element.
	* @returns {Interfaces.Classifier}
	*/
	public getFirstParent(): Interfaces.Classifier | null
	{
		return this.modelDelegate.getFirstParent(this);
	}
	/**
	* Gives all of the immediate ancestors of a generalized Classifier.
	* @returns {Interfaces.Classifier[]}
	*/
	public getParents(): Interfaces.Classifier[]
	{
		return this.modelDelegate.getParents(this);
	}
	/**
	* Returns all of the direct and indirect ancestors of a generalized Classifier, working outwards: more
	* specific classifiers will appear before more general classifiers.
	* @returns {Interfaces.Classifier[]}
	*/
	public getAllParents(): Interfaces.Classifier[]
	{
		return this.modelDelegate.getAllParents(this);
	}
	/**
	* Gets all classifiers of which this classifier is a direct general.
	* @returns {Interfaces.Classifier[]}
	*/
	public getSpecializations(): Interfaces.Classifier[]
	{
		return this.modelDelegate.getSpecializations(this);
	}
	/**
	* Gets all classifiers of which this element is a direct or indirect general.
	* @returns {Interfaces.Classifier[]}
	*/
	public getAllSpecializations(): Interfaces.Classifier[]
	{
		return this.modelDelegate.getAllSpecializations(this);
	}
	/**
	* Gets all packages that contain this Package, working inwards from the top Package to the owning
	* package.
	* @returns {Interfaces.Package[]} A collection of Packages.
	*/
	public getNestingPackages(): Interfaces.Package[]
	{
		return this.modelDelegate.getNestingPackages(this);
	}
	/**
	* Constructs a name from the names of the nesting packages. The name is constructed working inwards
	* from the package that is defined as namespace root up to but not including the PackageableElement
	* itself.
	* @param {string} separator The string to use to separate names. If not specified, a dot "." will be
	* used.
	* @returns {string} A single string with all the names separated.
	*/
	public getNamespaceName(separator?: string): string
	{
		return this.modelDelegate.getNamespaceName(this, separator);
	}
	/**
	* Constructs a name from the PackageableElement and the names of the nesting packages. The name is
	* constructed working inwards from the package that is defined as namespace root up to and including
	* the PackageableElement itself.
	* @param {string} separator The string to use to separate names. If not specified, a dot "." will be
	* used.
	* @returns {string} A single string with all the names separated.
	*/
	public getQualifiedName(separator?: string): string
	{
		return this.modelDelegate.getQualifiedName(this, separator);
	}
}

export class Generalization extends Element implements Interfaces.Generalization
{
	constructor(modelDelegate:ModelDelegate, owner: Interfaces.Element | null) {super(modelDelegate, owner);}
	public readonly elementType:Interfaces.ElementType = Interfaces.ElementType.generalization;
	public isSubstitutable: boolean = false;
	public get specific(): Interfaces.Classifier {
		return this.modelDelegate.getSpecific(this);
	}
	public general!: Interfaces.Classifier;
	public appliedStereotypes: Interfaces.Stereotype[] = [];
	public taggedValues: Interfaces.TaggedValueSpecification[] = [];
}

export class EnumerationLiteral extends Element implements Interfaces.EnumerationLiteral
{
	constructor(modelDelegate:ModelDelegate, owner: Interfaces.Element | null) {super(modelDelegate, owner);}
	public readonly elementType:Interfaces.ElementType = Interfaces.ElementType.enumerationLiteral;
	public get enumeration(): Interfaces.Enumeration {
		return this.modelDelegate.getEnumeration(this);
	}
	public specification!: Interfaces.ValueSpecification;
	public name: string = '';
	public visibility: Interfaces.VisibilityKind | null = null;
	public appliedStereotypes: Interfaces.Stereotype[] = [];
	public taggedValues: Interfaces.TaggedValueSpecification[] = [];
	public order: number = 0;
	/**
	* Gets the value of the Specification property.
	* @returns {any} The default value (the type depending on the type of value), or null if no default
	* value can be determined.
	*/
	public getSpecificationValue(): any | null
	{
		return this.modelDelegate.getSpecificationValue(this);
	}
}

export class Enumeration extends Element implements Interfaces.Enumeration
{
	constructor(modelDelegate:ModelDelegate, owner: Interfaces.Element | null) {super(modelDelegate, owner);}
	public readonly elementType:Interfaces.ElementType = Interfaces.ElementType.enumeration;
	public ownedLiterals: Interfaces.EnumerationLiteral[] = [];
	public baseType: Interfaces.Type | null = null;
	public ownedAttributes: Interfaces.Property[] = [];
	public ownedOperations: Interfaces.Operation[] = [];
	public isAbstract: boolean = false;
	public isFinalSpecialization: boolean = false;
	public generalizations: Interfaces.Generalization[] = [];
	public isInferred: boolean = false;
	public get package(): Interfaces.Package {
		return this.modelDelegate.getPackage(this);
	}
	public name: string = '';
	public visibility: Interfaces.VisibilityKind | null = null;
	public appliedStereotypes: Interfaces.Stereotype[] = [];
	public taggedValues: Interfaces.TaggedValueSpecification[] = [];
	public isLeaf: boolean = false;
	/**
	* Returns both inherited and owned attributes.
	* @returns {Interfaces.Property[]}
	*/
	public getAllAttributes(): Interfaces.Property[]
	{
		return this.modelDelegate.getAllAttributes(this);
	}
	/**
	* Returns both inherited and owned operations. Any inherited operation that has the same signature
	* (having the same name and parameter type order) in an inheriting type is not included.
	* @returns {Interfaces.Operation[]}
	*/
	public getAllOperations(): Interfaces.Operation[]
	{
		return this.modelDelegate.getAllOperations(this);
	}
	/**
	* Gets the first direct generalization relationship of the element.
	* @returns {Interfaces.Generalization}
	*/
	public getFirstGeneralization(): Interfaces.Generalization | null
	{
		return this.modelDelegate.getFirstGeneralization(this);
	}
	/**
	* Gets the first classifier that is an immediate general of the current element.
	* @returns {Interfaces.Classifier}
	*/
	public getFirstParent(): Interfaces.Classifier | null
	{
		return this.modelDelegate.getFirstParent(this);
	}
	/**
	* Gives all of the immediate ancestors of a generalized Classifier.
	* @returns {Interfaces.Classifier[]}
	*/
	public getParents(): Interfaces.Classifier[]
	{
		return this.modelDelegate.getParents(this);
	}
	/**
	* Returns all of the direct and indirect ancestors of a generalized Classifier, working outwards: more
	* specific classifiers will appear before more general classifiers.
	* @returns {Interfaces.Classifier[]}
	*/
	public getAllParents(): Interfaces.Classifier[]
	{
		return this.modelDelegate.getAllParents(this);
	}
	/**
	* Gets all classifiers of which this classifier is a direct general.
	* @returns {Interfaces.Classifier[]}
	*/
	public getSpecializations(): Interfaces.Classifier[]
	{
		return this.modelDelegate.getSpecializations(this);
	}
	/**
	* Gets all classifiers of which this element is a direct or indirect general.
	* @returns {Interfaces.Classifier[]}
	*/
	public getAllSpecializations(): Interfaces.Classifier[]
	{
		return this.modelDelegate.getAllSpecializations(this);
	}
	/**
	* Gets all packages that contain this Package, working inwards from the top Package to the owning
	* package.
	* @returns {Interfaces.Package[]} A collection of Packages.
	*/
	public getNestingPackages(): Interfaces.Package[]
	{
		return this.modelDelegate.getNestingPackages(this);
	}
	/**
	* Constructs a name from the names of the nesting packages. The name is constructed working inwards
	* from the package that is defined as namespace root up to but not including the PackageableElement
	* itself.
	* @param {string} separator The string to use to separate names. If not specified, a dot "." will be
	* used.
	* @returns {string} A single string with all the names separated.
	*/
	public getNamespaceName(separator?: string): string
	{
		return this.modelDelegate.getNamespaceName(this, separator);
	}
	/**
	* Constructs a name from the PackageableElement and the names of the nesting packages. The name is
	* constructed working inwards from the package that is defined as namespace root up to and including
	* the PackageableElement itself.
	* @param {string} separator The string to use to separate names. If not specified, a dot "." will be
	* used.
	* @returns {string} A single string with all the names separated.
	*/
	public getQualifiedName(separator?: string): string
	{
		return this.modelDelegate.getQualifiedName(this, separator);
	}
}

export class Comment extends Element implements Interfaces.Comment
{
	constructor(modelDelegate:ModelDelegate, owner: Interfaces.Element | null) {super(modelDelegate, owner);}
	public readonly elementType:Interfaces.ElementType = Interfaces.ElementType.comment;
	public body: string = '';
	public appliedStereotypes: Interfaces.Stereotype[] = [];
	public taggedValues: Interfaces.TaggedValueSpecification[] = [];
}

export class Association extends Element implements Interfaces.Association
{
	constructor(modelDelegate:ModelDelegate, owner: Interfaces.Element | null) {super(modelDelegate, owner);}
	public readonly elementType:Interfaces.ElementType = Interfaces.ElementType.association;
	public memberEnds: Interfaces.Property[] = [];
	public ownedEnds: Interfaces.Property[] = [];
	public appliedStereotypes: Interfaces.Stereotype[] = [];
	public taggedValues: Interfaces.TaggedValueSpecification[] = [];
	public isAbstract: boolean = false;
	public isFinalSpecialization: boolean = false;
	public generalizations: Interfaces.Generalization[] = [];
	public isInferred: boolean = false;
	public get package(): Interfaces.Package {
		return this.modelDelegate.getPackage(this);
	}
	public name: string = '';
	public visibility: Interfaces.VisibilityKind | null = null;
	public isLeaf: boolean = false;
	/**
	* Gets the first direct generalization relationship of the element.
	* @returns {Interfaces.Generalization}
	*/
	public getFirstGeneralization(): Interfaces.Generalization | null
	{
		return this.modelDelegate.getFirstGeneralization(this);
	}
	/**
	* Gets the first classifier that is an immediate general of the current element.
	* @returns {Interfaces.Classifier}
	*/
	public getFirstParent(): Interfaces.Classifier | null
	{
		return this.modelDelegate.getFirstParent(this);
	}
	/**
	* Gives all of the immediate ancestors of a generalized Classifier.
	* @returns {Interfaces.Classifier[]}
	*/
	public getParents(): Interfaces.Classifier[]
	{
		return this.modelDelegate.getParents(this);
	}
	/**
	* Returns all of the direct and indirect ancestors of a generalized Classifier, working outwards: more
	* specific classifiers will appear before more general classifiers.
	* @returns {Interfaces.Classifier[]}
	*/
	public getAllParents(): Interfaces.Classifier[]
	{
		return this.modelDelegate.getAllParents(this);
	}
	/**
	* Gets all classifiers of which this classifier is a direct general.
	* @returns {Interfaces.Classifier[]}
	*/
	public getSpecializations(): Interfaces.Classifier[]
	{
		return this.modelDelegate.getSpecializations(this);
	}
	/**
	* Gets all classifiers of which this element is a direct or indirect general.
	* @returns {Interfaces.Classifier[]}
	*/
	public getAllSpecializations(): Interfaces.Classifier[]
	{
		return this.modelDelegate.getAllSpecializations(this);
	}
	/**
	* Gets all packages that contain this Package, working inwards from the top Package to the owning
	* package.
	* @returns {Interfaces.Package[]} A collection of Packages.
	*/
	public getNestingPackages(): Interfaces.Package[]
	{
		return this.modelDelegate.getNestingPackages(this);
	}
	/**
	* Constructs a name from the names of the nesting packages. The name is constructed working inwards
	* from the package that is defined as namespace root up to but not including the PackageableElement
	* itself.
	* @param {string} separator The string to use to separate names. If not specified, a dot "." will be
	* used.
	* @returns {string} A single string with all the names separated.
	*/
	public getNamespaceName(separator?: string): string
	{
		return this.modelDelegate.getNamespaceName(this, separator);
	}
	/**
	* Constructs a name from the PackageableElement and the names of the nesting packages. The name is
	* constructed working inwards from the package that is defined as namespace root up to and including
	* the PackageableElement itself.
	* @param {string} separator The string to use to separate names. If not specified, a dot "." will be
	* used.
	* @returns {string} A single string with all the names separated.
	*/
	public getQualifiedName(separator?: string): string
	{
		return this.modelDelegate.getQualifiedName(this, separator);
	}
}
