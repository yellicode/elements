/*
* Copyright (c) 2018 Yellicode
*
* This Source Code Form is subject to the terms of the Mozilla Public
* License, v. 2.0. If a copy of the MPL was not distributed with this
* file, You can obtain one at http://mozilla.org/MPL/2.0/.
*/

/**
* This code was generated by a tool.
* 
* Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
*/
import { StringUtility } from '@yellicode/core';
import * as Interfaces from "./interfaces";
import * as Data from "./data-interfaces";
import * as Classes from "./classes";
import { ModelDelegate } from "./model-delegate";
import { ElementMap}  from "./element-map";
import { ProfileExtender } from "./profile-extender";
import { ElementComparer } from "./element-comparer";

const PRIMITIVE_BOOLEAN_ID = "boolean_id";
const PRIMITIVE_INTEGER_ID = "integer_id";
const PRIMITIVE_REAL_ID = "real_id";
const PRIMITIVE_STRING_ID = "string_id";
const PRIMITIVE_OBJECT_ID = "object_id";
const PRIMITIVE_UNLIMITEDNATURAL_ID = "unlimitednatural_id";

export class DataToModelConverter
{
	private referencesToResolve: {target:any, data:any, resolvefn: (target:any, element:any) => void }[] = [];
	private elementMap: ElementMap = new ElementMap();
	private elementIdPrefix: string | null = null;
	public modelDelegate: ModelDelegate = new ModelDelegate(this.elementMap);

	private createPrimitiveTypes(): Interfaces.PrimitiveType[]
	{
		const result:Interfaces.PrimitiveType[] = [];

		const booleanType = new Classes.PrimitiveType(this.modelDelegate, null);
		booleanType.id = PRIMITIVE_BOOLEAN_ID;
		booleanType.name = 'boolean';
		result.push(booleanType);

		const integerType = new Classes.PrimitiveType(this.modelDelegate, null);
		integerType.id = PRIMITIVE_INTEGER_ID;
		integerType.name = 'integer';
		result.push(integerType);

		const realType = new Classes.PrimitiveType(this.modelDelegate, null);
		realType.id = PRIMITIVE_REAL_ID;
		realType.name = 'real';
		result.push(realType);

		const stringType = new Classes.PrimitiveType(this.modelDelegate, null);
		stringType.id = PRIMITIVE_STRING_ID;
		stringType.name = 'string';
		result.push(stringType);

		const objectType = new Classes.PrimitiveType(this.modelDelegate, null);
		objectType.id = PRIMITIVE_OBJECT_ID;
		objectType.name = 'object';
		result.push(objectType);

		const unlimitedNaturalType = new Classes.PrimitiveType(this.modelDelegate, null);
		unlimitedNaturalType.id = PRIMITIVE_UNLIMITEDNATURAL_ID;
		unlimitedNaturalType.name = 'UnlimitedNatural';
		result.push(unlimitedNaturalType);
		return result;
	}

	private createElementType(data: Data.ElementType): Interfaces.ElementType
	{
		switch (data) // serialized as string
		{
			case 'class': return Interfaces.ElementType.class;
			case 'stereotype': return Interfaces.ElementType.stereotype;
			case 'package': return Interfaces.ElementType.package;
			case 'profile': return Interfaces.ElementType.profile;
			case 'property': return Interfaces.ElementType.property;
			case 'dataType': return Interfaces.ElementType.dataType;
			case 'primitiveType': return Interfaces.ElementType.primitiveType;
			case 'parameter': return Interfaces.ElementType.parameter;
			case 'operation': return Interfaces.ElementType.operation;
			case 'model': return Interfaces.ElementType.model;
			case 'literalUnlimitedNatural': return Interfaces.ElementType.literalUnlimitedNatural;
			case 'literalString': return Interfaces.ElementType.literalString;
			case 'literalReal': return Interfaces.ElementType.literalReal;
			case 'literalNull': return Interfaces.ElementType.literalNull;
			case 'literalInteger': return Interfaces.ElementType.literalInteger;
			case 'literalBoolean': return Interfaces.ElementType.literalBoolean;
			case 'interfaceRealization': return Interfaces.ElementType.interfaceRealization;
			case 'interface': return Interfaces.ElementType.interface;
			case 'generalization': return Interfaces.ElementType.generalization;
			case 'enumerationLiteral': return Interfaces.ElementType.enumerationLiteral;
			case 'enumeration': return Interfaces.ElementType.enumeration;
			case 'comment': return Interfaces.ElementType.comment;
			case 'association': return Interfaces.ElementType.association;
			default: throw `Error reading model. Could not map ElementType value '${data}'.`;
		}
	}


    constructor() {
        const primitiveTypes = this.createPrimitiveTypes();
        primitiveTypes.forEach(t => {
            this.elementMap.addElement(t, null);
        });
    }

    /**
     * NOTE: this function must be edited in the partial template file.
     */
    private createElementId(elementId: string): string {
        // ids must be prefixed if we are loading a referenced document, because references to it 
        // are prefixed with the document id      
        return this.elementIdPrefix ? this.elementIdPrefix + '.' + elementId : elementId;
    }

    /**
     * NOTE: this function must be edited in the partial template file.
     */
    public convert(data: Data.ModelData, profiles: Interfaces.Profile[] | null, elementIdPrefix: string | null): Interfaces.Model {

        this.elementIdPrefix = elementIdPrefix;

        // Extend prototypes with profile specific accessors
        if (profiles) {
            ProfileExtender.applyProfiles(profiles);
        }

        // Load the object tree recursively. This will fill elementMap and referencesToResolve.
        const model = this.createModel(data);
        
        // Now the object tree is loaded, set references between objects
        this.referencesToResolve.forEach((item) => {
            item.resolvefn.call(this, item.target, item.data);
        });
        this.referencesToResolve = []; // Release this list

        return model;
    }

    /**
     * NOTE: this function must be edited in the partial template file.
     */
    private addElementById(data: Data.ElementData, element: Interfaces.Element) {
        if ((!data.id || data.id.length === 0)) {
            // The following element types do not require an id 
            if (data.elementType !== 'enumerationLiteral' && data.elementType !== 'comment' && !DataToModelConverter.isValueSpecification(data.elementType)) {
                console.warn(`Mising id on element of type '${data.elementType}'.`);
            }
            return;
        }
        this.elementMap.addElement(element, data);
    }

    /**
     * Gets the id of the matching built-in primitive type if the element type is a literal type.
     * NOTE: this function must be edited in the partial template file.
     */
    private static getTypeIdIfLiteralType(elementType: Data.ElementType): string | undefined {
        switch (elementType) {
            case 'literalBoolean':
                return PRIMITIVE_BOOLEAN_ID;
            case 'literalInteger':
                return PRIMITIVE_INTEGER_ID;
            case 'literalReal':
                return PRIMITIVE_REAL_ID;
            case 'literalString':
                return PRIMITIVE_STRING_ID;
            case 'literalUnlimitedNatural':
                return PRIMITIVE_UNLIMITEDNATURAL_ID;
            default:
                // TODO: deal with literalNull?			
                return undefined; // returns undefined because the result is assigned to a data property "type?: string;"
        }
    }

    /**
   * Custom function to create element properties from tagged values. 
   * NOTE: this function must be edited in the partial template file.
   */
    private mapTaggedValues(data: Data.ElementData, element: Interfaces.Element): void {
        if (!data.appliedStereotypes)
            return;

        // Get the stereotypes applied to this element. For each stereotype, get the meta properties.	
        // Note that we should not use element.appliedStereotypes because that data is not available
        // at this point.
        data.appliedStereotypes.forEach(stereotypeId => {
            // Lookup the stereotype by id. It should be indexed because the profiles are loaded first
            const st: Interfaces.Stereotype | null = this.elementMap.getElementById<Interfaces.Stereotype>(stereotypeId);
            if (!st) {
                return console.warn(`Element ${element.id} refers to undefined stereotype ${stereotypeId}.`);
            }
			(element as any)["stereotypeName"] = st.name; // always generated
            var stereotypeMetaProperties = st.getAllAttributes(); // stereotypes can inherit other stereotypes
            stereotypeMetaProperties.forEach(metaProperty => {
                if (element.hasOwnProperty(metaProperty.name))
                    return;

                //  Extend the element with the property. But determine the value first.				
                let valueSpecification: Interfaces.ValueSpecification | null = null;
                const taggedValue = data.taggedValues ? data.taggedValues.find(v => v.definition === metaProperty.id) : null;
                if (taggedValue) {
                    valueSpecification = this.createValueSpecification(taggedValue.specification, element);
                }
                else if (metaProperty.defaultValue) {
                    valueSpecification = metaProperty.defaultValue;
                }
                (element as any)[metaProperty.name] = valueSpecification ? valueSpecification.getValue() : null;
            })
        });
    }
    
	private createDocumentLocationKind(data: Data.DocumentLocationKind): Interfaces.DocumentLocationKind
	{
		switch (data) // serialized as string
		{
			case 'local': return Interfaces.DocumentLocationKind.local;
			case 'npm': return Interfaces.DocumentLocationKind.npm;
			default: throw `Error reading model. Could not map DocumentLocationKind value '${data}'.`;
		}
	}

	private mapDocumentReference(data: Data.DocumentReferenceData, target: Interfaces.DocumentReference, owner: Interfaces.Element): void
	{
		if (data.location) { target.location = this.createDocumentLocationKind(data.location);}
		if (data.name) { target.name = data.name; }
		if (data.path) { target.path = data.path; }
	}

	private createDocumentReference(data: Data.DocumentReferenceData, owner: Interfaces.Element): Interfaces.DocumentReference
	{
		const element = new Classes.DocumentReference();
		this.mapDocumentReference(data, element, owner);
		return element;
	}

	private mapStereotypeExtension(data: Data.StereotypeExtensionData, target: Interfaces.StereotypeExtension, owner: Interfaces.Element): void
	{
		if (data.isRequired) { target.isRequired = data.isRequired; }
		if (data.metaClass) { target.metaClass = this.createElementType(data.metaClass);}
	}

	private createStereotypeExtension(data: Data.StereotypeExtensionData, owner: Interfaces.Element): Interfaces.StereotypeExtension
	{
		const element = new Classes.StereotypeExtension();
		this.mapStereotypeExtension(data, element, owner);
		return element;
	}

	private mapTaggedValueSpecification(data: Data.TaggedValueSpecificationData, target: Interfaces.TaggedValueSpecification, owner: Interfaces.Element): void
	{
		if (data.specification) { target.specification = this.createValueSpecification(data.specification, owner);}
		this.referencesToResolve.push({target:target, data:data, resolvefn: this.resolveTaggedValueSpecificationReferences});
	}

	private resolveTaggedValueSpecificationReferences(target: Interfaces.TaggedValueSpecification, data: Data.TaggedValueSpecificationData): void
	{
		if (!data.definition) console.error(`Unable to set property 'definition'. The following data is missing a 'definition' field: ${JSON.stringify(data)}.`);
		const definition = this.elementMap.getElementById<Interfaces.Property>(data.definition);
		if (definition) { target.definition = definition } else console.error(`Unable to set property 'definition'. Property with id '${data.definition}' does not exist.`);
	}

	private createTaggedValueSpecification(data: Data.TaggedValueSpecificationData, owner: Interfaces.Element): Interfaces.TaggedValueSpecification
	{
		const element = new Classes.TaggedValueSpecification();
		this.mapTaggedValueSpecification(data, element, owner);
		return element;
	}

	private mapElement(data: Data.ElementData, target: Interfaces.Element, owner: Interfaces.Element): void
	{
		target.id = this.createElementId(data.id);
		if (data.ownedComments) { target.ownedComments.push(...data.ownedComments.map((e) => { return this.createComment(e, target); }));}
		if (data.taggedValues) { target.taggedValues.push(...data.taggedValues.map((e) => { return this.createTaggedValueSpecification(e, target); }));}
		this.referencesToResolve.push({target:target, data:data, resolvefn: this.resolveElementReferences});
	}

	private resolveElementReferences(target: Interfaces.Element, data: Data.ElementData): void
	{
		if (data.appliedStereotypes) { target.appliedStereotypes.push(...this.elementMap.getElementsByIdList<Interfaces.Stereotype>(data.appliedStereotypes));}
	}

	private mapNamedElement(data: Data.NamedElementData, target: Interfaces.NamedElement, owner: Interfaces.Element): void
	{
		if (data.name) { target.name = data.name; }
		if (data.visibility) { target.visibility = this.createVisibilityKind(data.visibility);}
	}

	private mapRedefinableElement(data: Data.RedefinableElementData, target: Interfaces.RedefinableElement, owner: Interfaces.Element): void
	{
		if (data.isLeaf) { target.isLeaf = data.isLeaf; }
	}

	private mapPackageableElement(data: Data.PackageableElementData, target: Interfaces.PackageableElement, owner: Interfaces.Element): void
	{
	}

	private createPackageableElement(data: Data.PackageableElementData, owner: Interfaces.Element): Interfaces.PackageableElement
	{
		let result: Interfaces.PackageableElement;
		switch (data.elementType)
		{
			case "class":
				return this.createClass(<Data.ClassData>data, owner);
			case "stereotype":
				return this.createStereotype(<Data.StereotypeData>data, owner);
			case "dataType":
				return this.createDataType(<Data.DataTypeData>data, owner);
			case "primitiveType":
				return this.createPrimitiveType(<Data.PrimitiveTypeData>data, owner);
			case "enumeration":
				return this.createEnumeration(<Data.EnumerationData>data, owner);
			case "interface":
				return this.createInterface(<Data.InterfaceData>data, owner);
			case "association":
				return this.createAssociation(<Data.AssociationData>data, owner);
			case "package":
				return this.createPackage(<Data.PackageData>data, owner);
			case "profile":
				return this.createProfile(<Data.ProfileData>data, owner);
			default: throw `Error reading model. Could not map PackageableElement of type ${data.elementType}.`;
		}
	}

	private static isPackageableElement(elementType: Data.ElementType): boolean
	{
		switch (elementType)
		{
			case "class":
			case "stereotype":
			case "dataType":
			case "primitiveType":
			case "enumeration":
			case "interface":
			case "association":
			case "package":
			case "profile":
				return true;
			default: return false;
		}
	}

	private mapType(data: Data.TypeData, target: Interfaces.Type, owner: Interfaces.Element): void
	{
		if (data.isInferred) { target.isInferred = data.isInferred; }
	}

	private mapClassifier(data: Data.ClassifierData, target: Interfaces.Classifier, owner: Interfaces.Element): void
	{
		if (data.generalizations) { target.generalizations.push(...data.generalizations.map((e) => { return this.createGeneralization(e, target); }));}
		if (data.isAbstract) { target.isAbstract = data.isAbstract; }
		if (data.isFinalSpecialization) { target.isFinalSpecialization = data.isFinalSpecialization; }
	}

	private mapMemberedClassifier(data: Data.MemberedClassifierData, target: Interfaces.MemberedClassifier, owner: Interfaces.Element): void
	{
		if (data.ownedAttributes) { target.ownedAttributes.push(...data.ownedAttributes.map((e) => { return this.createProperty(e, target); }).sort(ElementComparer.compareOrderedElements));}
		if (data.ownedOperations) { target.ownedOperations.push(...data.ownedOperations.map((e) => { return this.createOperation(e, target); }).sort(ElementComparer.compareOrderedElements));}
	}

	private mapBehavioredClassifier(data: Data.BehavioredClassifierData, target: Interfaces.BehavioredClassifier, owner: Interfaces.Element): void
	{
		if (data.interfaceRealizations) { target.interfaceRealizations.push(...data.interfaceRealizations.map((e) => { return this.createInterfaceRealization(e, target); }));}
	}

	private mapClass(data: Data.ClassData, target: Interfaces.Class, owner: Interfaces.Element): void
	{
		if (data.isActive) { target.isActive = data.isActive; }
	}

	private createClass(data: Data.ClassData, owner: Interfaces.Element): Interfaces.Class
	{
		const element = new Classes.Class(this.modelDelegate, owner);
		this.mapElement(data, element, element);
		this.mapNamedElement(data, element, element);
		this.mapPackageableElement(data, element, element);
		this.mapType(data, element, element);
		this.mapRedefinableElement(data, element, element);
		this.mapClassifier(data, element, element);
		this.mapBehavioredClassifier(data, element, element);
		this.mapMemberedClassifier(data, element, element);
		this.mapClass(data, element, element);
		this.mapTaggedValues(data, element); // added by code generation
		this.addElementById(data, element);
		return element;
	}

	private mapStereotype(data: Data.StereotypeData, target: Interfaces.Stereotype, owner: Interfaces.Element): void
	{
		if (data.extends) { target.extends.push(...data.extends.map((e) => { return this.createStereotypeExtension(e, target); }));}
		if (data.safeName) { target.safeName = data.safeName; }
	}

	private createStereotype(data: Data.StereotypeData, owner: Interfaces.Element): Interfaces.Stereotype
	{
		const element = new Classes.Stereotype(this.modelDelegate, owner);
		this.mapElement(data, element, element);
		this.mapNamedElement(data, element, element);
		this.mapPackageableElement(data, element, element);
		this.mapType(data, element, element);
		this.mapRedefinableElement(data, element, element);
		this.mapClassifier(data, element, element);
		this.mapBehavioredClassifier(data, element, element);
		this.mapMemberedClassifier(data, element, element);
		this.mapClass(data, element, element);
		this.mapStereotype(data, element, element);
		this.mapTaggedValues(data, element); // added by code generation
		this.addElementById(data, element);
		return element;
	}

	private mapPackage(data: Data.PackageData, target: Interfaces.Package, owner: Interfaces.Element): void
	{
		if (data.isNamespaceRoot) { target.isNamespaceRoot = data.isNamespaceRoot; }
		if (data.packagedElements) { target.packagedElements.push(...data.packagedElements.map((e) => { return this.createPackageableElement(e, target); }).sort(ElementComparer.comparePackageableElements));}
		this.referencesToResolve.push({target:target, data:data, resolvefn: this.resolvePackageReferences});
	}

	private resolvePackageReferences(target: Interfaces.Package, data: Data.PackageData): void
	{
		if (data.appliedProfiles) { target.appliedProfiles.push(...this.elementMap.getElementsByIdList<Interfaces.Profile>(data.appliedProfiles));}
	}

	private createPackage(data: Data.PackageData, owner: Interfaces.Element): Interfaces.Package
	{
		const element = new Classes.Package(this.modelDelegate, owner);
		this.mapElement(data, element, element);
		this.mapNamedElement(data, element, element);
		this.mapPackageableElement(data, element, element);
		this.mapPackage(data, element, element);
		this.mapTaggedValues(data, element); // added by code generation
		this.addElementById(data, element);
		return element;
	}

	private mapProfile(data: Data.ProfileData, target: Interfaces.Profile, owner: Interfaces.Element): void
	{
		if (data.safeName) { target.safeName = data.safeName; }
	}

	private createProfile(data: Data.ProfileData, owner: Interfaces.Element): Interfaces.Profile
	{
		const element = new Classes.Profile(this.modelDelegate, owner);
		this.mapElement(data, element, element);
		this.mapNamedElement(data, element, element);
		this.mapPackageableElement(data, element, element);
		this.mapPackage(data, element, element);
		this.mapProfile(data, element, element);
		this.mapTaggedValues(data, element); // added by code generation
		this.addElementById(data, element);
		return element;
	}

	private mapOrderedElement(data: Data.OrderedElementData, target: Interfaces.OrderedElement, owner: Interfaces.Element): void
	{
		if (data.order) { target.order = data.order; }
	}

	private createVisibilityKind(data: Data.VisibilityKind): Interfaces.VisibilityKind
	{
		switch (data) // serialized as string
		{
			case 'public': return Interfaces.VisibilityKind.public;
			case 'private': return Interfaces.VisibilityKind.private;
			case 'protected': return Interfaces.VisibilityKind.protected;
			case 'package': return Interfaces.VisibilityKind.package;
			default: throw `Error reading model. Could not map VisibilityKind value '${data}'.`;
		}
	}

	private mapTypedElement(data: Data.TypedElementData, target: Interfaces.TypedElement, owner: Interfaces.Element): void
	{
		this.referencesToResolve.push({target:target, data:data, resolvefn: this.resolveTypedElementReferences});
	}

	private resolveTypedElementReferences(target: Interfaces.TypedElement, data: Data.TypedElementData): void
	{
		// Special case for TypedElement: if this is a literal specification, the type can be a predefined primitive.
		if (!data.type) {data.type = DataToModelConverter.getTypeIdIfLiteralType(data.elementType);}
		target.type = data.type ? this.elementMap.getElementById<Interfaces.Type>(data.type) : null;
	}

	private createValueSpecification(data: Data.ValueSpecificationData, owner: Interfaces.Element): Interfaces.ValueSpecification
	{
		let result: Interfaces.ValueSpecification;
		switch (data.elementType)
		{
			case "literalUnlimitedNatural":
				return this.createLiteralUnlimitedNatural(<Data.LiteralUnlimitedNaturalData>data, owner);
			case "literalString":
				return this.createLiteralString(<Data.LiteralStringData>data, owner);
			case "literalReal":
				return this.createLiteralReal(<Data.LiteralRealData>data, owner);
			case "literalNull":
				return this.createLiteralNull(<Data.LiteralNullData>data, owner);
			case "literalInteger":
				return this.createLiteralInteger(<Data.LiteralIntegerData>data, owner);
			case "literalBoolean":
				return this.createLiteralBoolean(<Data.LiteralBooleanData>data, owner);
			default: throw `Error reading model. Could not map ValueSpecification of type ${data.elementType}.`;
		}
	}

	private static isValueSpecification(elementType: Data.ElementType): boolean
	{
		switch (elementType)
		{
			case "literalUnlimitedNatural":
			case "literalString":
			case "literalReal":
			case "literalNull":
			case "literalInteger":
			case "literalBoolean":
				return true;
			default: return false;
		}
	}

	private mapMultiplicityElement(data: Data.MultiplicityElementData, target: Interfaces.MultiplicityElement, owner: Interfaces.Element): void
	{
		if (data.isOrdered) { target.isOrdered = data.isOrdered; }
		if (data.isUnique) { target.isUnique = data.isUnique; }
		if (data.lowerValue) { target.lowerValue = this.createValueSpecification(data.lowerValue, target);}
		if (data.upperValue) { target.upperValue = this.createValueSpecification(data.upperValue, target);}
	}

	private mapFeature(data: Data.FeatureData, target: Interfaces.Feature, owner: Interfaces.Element): void
	{
		if (data.isStatic) { target.isStatic = data.isStatic; }
	}

	private mapStructuralFeature(data: Data.StructuralFeatureData, target: Interfaces.StructuralFeature, owner: Interfaces.Element): void
	{
		if (data.isReadOnly) { target.isReadOnly = data.isReadOnly; }
	}

	private mapProperty(data: Data.PropertyData, target: Interfaces.Property, owner: Interfaces.Element): void
	{
		if (data.aggregation) { target.aggregation = this.createAggregationKind(data.aggregation);}
		if (data.defaultValue) { target.defaultValue = this.createValueSpecification(data.defaultValue, target);}
		if (data.isDerived) { target.isDerived = data.isDerived; }
		if (data.isDerivedUnion) { target.isDerivedUnion = data.isDerivedUnion; }
		if (data.isID) { target.isID = data.isID; }
		if (data.isNavigable) { target.isNavigable = data.isNavigable; }
	}

	private createProperty(data: Data.PropertyData, owner: Interfaces.Element): Interfaces.Property
	{
		const element = new Classes.Property(this.modelDelegate, owner);
		this.mapElement(data, element, element);
		this.mapNamedElement(data, element, element);
		this.mapRedefinableElement(data, element, element);
		this.mapOrderedElement(data, element, element);
		this.mapFeature(data, element, element);
		this.mapMultiplicityElement(data, element, element);
		this.mapTypedElement(data, element, element);
		this.mapStructuralFeature(data, element, element);
		this.mapProperty(data, element, element);
		this.mapTaggedValues(data, element); // added by code generation
		this.addElementById(data, element);
		return element;
	}

	private createDataType(data: Data.DataTypeData, owner: Interfaces.Element): Interfaces.DataType
	{
		const element = new Classes.DataType(this.modelDelegate, owner);
		this.mapElement(data, element, element);
		this.mapNamedElement(data, element, element);
		this.mapPackageableElement(data, element, element);
		this.mapType(data, element, element);
		this.mapRedefinableElement(data, element, element);
		this.mapClassifier(data, element, element);
		this.mapMemberedClassifier(data, element, element);
		this.mapTaggedValues(data, element); // added by code generation
		this.addElementById(data, element);
		return element;
	}

	private createPrimitiveType(data: Data.PrimitiveTypeData, owner: Interfaces.Element): Interfaces.PrimitiveType
	{
		const element = new Classes.PrimitiveType(this.modelDelegate, owner);
		this.mapElement(data, element, element);
		this.mapNamedElement(data, element, element);
		this.mapPackageableElement(data, element, element);
		this.mapType(data, element, element);
		this.mapRedefinableElement(data, element, element);
		this.mapClassifier(data, element, element);
		this.mapMemberedClassifier(data, element, element);
		this.mapTaggedValues(data, element); // added by code generation
		this.addElementById(data, element);
		return element;
	}

	private createParameterDirectionKind(data: Data.ParameterDirectionKind): Interfaces.ParameterDirectionKind
	{
		switch (data) // serialized as string
		{
			case 'in': return Interfaces.ParameterDirectionKind.in;
			case 'inout': return Interfaces.ParameterDirectionKind.inout;
			case 'out': return Interfaces.ParameterDirectionKind.out;
			case 'return': return Interfaces.ParameterDirectionKind.return;
			default: throw `Error reading model. Could not map ParameterDirectionKind value '${data}'.`;
		}
	}

	private mapParameter(data: Data.ParameterData, target: Interfaces.Parameter, owner: Interfaces.Element): void
	{
		if (data.defaultValue) { target.defaultValue = this.createValueSpecification(data.defaultValue, target);}
		if (data.direction) { target.direction = this.createParameterDirectionKind(data.direction);}
		if (data.isException) { target.isException = data.isException; }
		if (data.isStream) { target.isStream = data.isStream; }
	}

	private createParameter(data: Data.ParameterData, owner: Interfaces.Element): Interfaces.Parameter
	{
		const element = new Classes.Parameter(this.modelDelegate, owner);
		this.mapElement(data, element, element);
		this.mapNamedElement(data, element, element);
		this.mapTypedElement(data, element, element);
		this.mapMultiplicityElement(data, element, element);
		this.mapOrderedElement(data, element, element);
		this.mapParameter(data, element, element);
		this.mapTaggedValues(data, element); // added by code generation
		this.addElementById(data, element);
		return element;
	}

	private mapBehavioralFeature(data: Data.BehavioralFeatureData, target: Interfaces.BehavioralFeature, owner: Interfaces.Element): void
	{
		if (data.isAbstract) { target.isAbstract = data.isAbstract; }
		if (data.ownedParameters) { target.ownedParameters.push(...data.ownedParameters.map((e) => { return this.createParameter(e, target); }).sort(ElementComparer.compareOrderedElements));}
	}

	private mapOperation(data: Data.OperationData, target: Interfaces.Operation, owner: Interfaces.Element): void
	{
		if (data.isConstructor) { target.isConstructor = data.isConstructor; }
		if (data.isQuery) { target.isQuery = data.isQuery; }
	}

	private createOperation(data: Data.OperationData, owner: Interfaces.Element): Interfaces.Operation
	{
		const element = new Classes.Operation(this.modelDelegate, owner);
		this.mapElement(data, element, element);
		this.mapNamedElement(data, element, element);
		this.mapRedefinableElement(data, element, element);
		this.mapOrderedElement(data, element, element);
		this.mapFeature(data, element, element);
		this.mapBehavioralFeature(data, element, element);
		this.mapOperation(data, element, element);
		this.mapTaggedValues(data, element); // added by code generation
		this.addElementById(data, element);
		return element;
	}

	private createModel(data: Data.ModelData): Interfaces.Model
	{
		const element = new Classes.Model(this.modelDelegate, null);
		this.mapElement(data, element, element);
		this.mapNamedElement(data, element, element);
		this.mapPackageableElement(data, element, element);
		this.mapPackage(data, element, element);
		this.mapTaggedValues(data, element); // added by code generation
		this.addElementById(data, element);
		return element;
	}

	private mapLiteralUnlimitedNatural(data: Data.LiteralUnlimitedNaturalData, target: Interfaces.LiteralUnlimitedNatural, owner: Interfaces.Element): void
	{
		if (data.value) { target.value = new Interfaces.UnlimitedNatural(data.value); }
	}

	private createLiteralUnlimitedNatural(data: Data.LiteralUnlimitedNaturalData, owner: Interfaces.Element): Interfaces.LiteralUnlimitedNatural
	{
		const element = new Classes.LiteralUnlimitedNatural(this.modelDelegate, owner);
		this.mapElement(data, element, element);
		this.mapNamedElement(data, element, element);
		this.mapTypedElement(data, element, element);
		this.mapLiteralUnlimitedNatural(data, element, element);
		this.mapTaggedValues(data, element); // added by code generation
		this.addElementById(data, element);
		return element;
	}

	private mapLiteralString(data: Data.LiteralStringData, target: Interfaces.LiteralString, owner: Interfaces.Element): void
	{
		if (data.value) { target.value = data.value; }
	}

	private createLiteralString(data: Data.LiteralStringData, owner: Interfaces.Element): Interfaces.LiteralString
	{
		const element = new Classes.LiteralString(this.modelDelegate, owner);
		this.mapElement(data, element, element);
		this.mapNamedElement(data, element, element);
		this.mapTypedElement(data, element, element);
		this.mapLiteralString(data, element, element);
		this.mapTaggedValues(data, element); // added by code generation
		this.addElementById(data, element);
		return element;
	}

	private mapLiteralReal(data: Data.LiteralRealData, target: Interfaces.LiteralReal, owner: Interfaces.Element): void
	{
		if (data.value) { target.value = data.value; }
	}

	private createLiteralReal(data: Data.LiteralRealData, owner: Interfaces.Element): Interfaces.LiteralReal
	{
		const element = new Classes.LiteralReal(this.modelDelegate, owner);
		this.mapElement(data, element, element);
		this.mapNamedElement(data, element, element);
		this.mapTypedElement(data, element, element);
		this.mapLiteralReal(data, element, element);
		this.mapTaggedValues(data, element); // added by code generation
		this.addElementById(data, element);
		return element;
	}

	private createLiteralNull(data: Data.LiteralNullData, owner: Interfaces.Element): Interfaces.LiteralNull
	{
		const element = new Classes.LiteralNull(this.modelDelegate, owner);
		this.mapElement(data, element, element);
		this.mapNamedElement(data, element, element);
		this.mapTypedElement(data, element, element);
		this.mapTaggedValues(data, element); // added by code generation
		this.addElementById(data, element);
		return element;
	}

	private mapLiteralInteger(data: Data.LiteralIntegerData, target: Interfaces.LiteralInteger, owner: Interfaces.Element): void
	{
		if (data.value) { target.value = data.value; }
	}

	private createLiteralInteger(data: Data.LiteralIntegerData, owner: Interfaces.Element): Interfaces.LiteralInteger
	{
		const element = new Classes.LiteralInteger(this.modelDelegate, owner);
		this.mapElement(data, element, element);
		this.mapNamedElement(data, element, element);
		this.mapTypedElement(data, element, element);
		this.mapLiteralInteger(data, element, element);
		this.mapTaggedValues(data, element); // added by code generation
		this.addElementById(data, element);
		return element;
	}

	private mapLiteralBoolean(data: Data.LiteralBooleanData, target: Interfaces.LiteralBoolean, owner: Interfaces.Element): void
	{
		if (data.value) { target.value = data.value; }
	}

	private createLiteralBoolean(data: Data.LiteralBooleanData, owner: Interfaces.Element): Interfaces.LiteralBoolean
	{
		const element = new Classes.LiteralBoolean(this.modelDelegate, owner);
		this.mapElement(data, element, element);
		this.mapNamedElement(data, element, element);
		this.mapTypedElement(data, element, element);
		this.mapLiteralBoolean(data, element, element);
		this.mapTaggedValues(data, element); // added by code generation
		this.addElementById(data, element);
		return element;
	}

	private mapInterfaceRealization(data: Data.InterfaceRealizationData, target: Interfaces.InterfaceRealization, owner: Interfaces.Element): void
	{
		this.referencesToResolve.push({target:target, data:data, resolvefn: this.resolveInterfaceRealizationReferences});
	}

	private resolveInterfaceRealizationReferences(target: Interfaces.InterfaceRealization, data: Data.InterfaceRealizationData): void
	{
		if (!data.contract) console.error(`Unable to set property 'contract'. The following data is missing a 'contract' field: ${JSON.stringify(data)}.`);
		const contract = this.elementMap.getElementById<Interfaces.Interface>(data.contract);
		if (contract) { target.contract = contract } else console.error(`Unable to set property 'contract'. Interface with id '${data.contract}' does not exist.`);
	}

	private createInterfaceRealization(data: Data.InterfaceRealizationData, owner: Interfaces.Element): Interfaces.InterfaceRealization
	{
		const element = new Classes.InterfaceRealization(this.modelDelegate, owner);
		this.mapElement(data, element, element);
		this.mapInterfaceRealization(data, element, element);
		this.mapTaggedValues(data, element); // added by code generation
		this.addElementById(data, element);
		return element;
	}

	private createInterface(data: Data.InterfaceData, owner: Interfaces.Element): Interfaces.Interface
	{
		const element = new Classes.Interface(this.modelDelegate, owner);
		this.mapElement(data, element, element);
		this.mapNamedElement(data, element, element);
		this.mapPackageableElement(data, element, element);
		this.mapType(data, element, element);
		this.mapRedefinableElement(data, element, element);
		this.mapClassifier(data, element, element);
		this.mapMemberedClassifier(data, element, element);
		this.mapTaggedValues(data, element); // added by code generation
		this.addElementById(data, element);
		return element;
	}

	private mapGeneralization(data: Data.GeneralizationData, target: Interfaces.Generalization, owner: Interfaces.Element): void
	{
		if (data.isSubstitutable) { target.isSubstitutable = data.isSubstitutable; }
		this.referencesToResolve.push({target:target, data:data, resolvefn: this.resolveGeneralizationReferences});
	}

	private resolveGeneralizationReferences(target: Interfaces.Generalization, data: Data.GeneralizationData): void
	{
		if (!data.general) console.error(`Unable to set property 'general'. The following data is missing a 'general' field: ${JSON.stringify(data)}.`);
		const general = this.elementMap.getElementById<Interfaces.Classifier>(data.general);
		if (general) { target.general = general } else console.error(`Unable to set property 'general'. Classifier with id '${data.general}' does not exist.`);
	}

	private createGeneralization(data: Data.GeneralizationData, owner: Interfaces.Element): Interfaces.Generalization
	{
		const element = new Classes.Generalization(this.modelDelegate, owner);
		this.mapElement(data, element, element);
		this.mapGeneralization(data, element, element);
		this.mapTaggedValues(data, element); // added by code generation
		this.addElementById(data, element);
		return element;
	}

	private mapEnumerationLiteral(data: Data.EnumerationLiteralData, target: Interfaces.EnumerationLiteral, owner: Interfaces.Element): void
	{
		if (data.specification) { target.specification = this.createValueSpecification(data.specification, target);}
	}

	private createEnumerationLiteral(data: Data.EnumerationLiteralData, owner: Interfaces.Element): Interfaces.EnumerationLiteral
	{
		const element = new Classes.EnumerationLiteral(this.modelDelegate, owner);
		this.mapElement(data, element, element);
		this.mapNamedElement(data, element, element);
		this.mapOrderedElement(data, element, element);
		this.mapEnumerationLiteral(data, element, element);
		this.mapTaggedValues(data, element); // added by code generation
		this.addElementById(data, element);
		return element;
	}

	private mapEnumeration(data: Data.EnumerationData, target: Interfaces.Enumeration, owner: Interfaces.Element): void
	{
		if (data.ownedLiterals) { target.ownedLiterals.push(...data.ownedLiterals.map((e) => { return this.createEnumerationLiteral(e, target); }).sort(ElementComparer.compareOrderedElements));}
		this.referencesToResolve.push({target:target, data:data, resolvefn: this.resolveEnumerationReferences});
	}

	private resolveEnumerationReferences(target: Interfaces.Enumeration, data: Data.EnumerationData): void
	{
		target.baseType = data.baseType ? this.elementMap.getElementById<Interfaces.Type>(data.baseType) : null;
	}

	private createEnumeration(data: Data.EnumerationData, owner: Interfaces.Element): Interfaces.Enumeration
	{
		const element = new Classes.Enumeration(this.modelDelegate, owner);
		this.mapElement(data, element, element);
		this.mapNamedElement(data, element, element);
		this.mapPackageableElement(data, element, element);
		this.mapType(data, element, element);
		this.mapRedefinableElement(data, element, element);
		this.mapClassifier(data, element, element);
		this.mapMemberedClassifier(data, element, element);
		this.mapEnumeration(data, element, element);
		this.mapTaggedValues(data, element); // added by code generation
		this.addElementById(data, element);
		return element;
	}

	private mapComment(data: Data.CommentData, target: Interfaces.Comment, owner: Interfaces.Element): void
	{
		if (data.body) { target.body = data.body; }
	}

	private createComment(data: Data.CommentData, owner: Interfaces.Element): Interfaces.Comment
	{
		const element = new Classes.Comment(this.modelDelegate, owner);
		this.mapElement(data, element, element);
		this.mapComment(data, element, element);
		this.mapTaggedValues(data, element); // added by code generation
		this.addElementById(data, element);
		return element;
	}

	private mapAssociation(data: Data.AssociationData, target: Interfaces.Association, owner: Interfaces.Element): void
	{
		if (data.ownedEnds) { target.ownedEnds.push(...data.ownedEnds.map((e) => { return this.createProperty(e, target); }).sort(ElementComparer.compareOrderedElements));}
		this.referencesToResolve.push({target:target, data:data, resolvefn: this.resolveAssociationReferences});
	}

	private resolveAssociationReferences(target: Interfaces.Association, data: Data.AssociationData): void
	{
		if (data.memberEnds) { target.memberEnds.push(...this.elementMap.getElementsByIdList<Interfaces.Property>(data.memberEnds));}
	}

	private createAssociation(data: Data.AssociationData, owner: Interfaces.Element): Interfaces.Association
	{
		const element = new Classes.Association(this.modelDelegate, owner);
		this.mapElement(data, element, element);
		this.mapNamedElement(data, element, element);
		this.mapPackageableElement(data, element, element);
		this.mapType(data, element, element);
		this.mapRedefinableElement(data, element, element);
		this.mapClassifier(data, element, element);
		this.mapAssociation(data, element, element);
		this.mapTaggedValues(data, element); // added by code generation
		this.addElementById(data, element);
		return element;
	}

	private createAggregationKind(data: Data.AggregationKind): Interfaces.AggregationKind
	{
		switch (data) // serialized as string
		{
			case 'none': return Interfaces.AggregationKind.none;
			case 'shared': return Interfaces.AggregationKind.shared;
			case 'composite': return Interfaces.AggregationKind.composite;
			default: throw `Error reading model. Could not map AggregationKind value '${data}'.`;
		}
	}

}
