/*
* Copyright (c) 2019 Yellicode
*
* This Source Code Form is subject to the terms of the Mozilla Public
* License, v. 2.0. If a copy of the MPL was not distributed with this
* file, You can obtain one at http://mozilla.org/MPL/2.0/.
*/

/**
* This code was generated by a tool.
* 
* Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
*/
import * as elements from './interfaces';
import * as data from './data-interfaces';
import * as classes from './classes';
import { ModelDelegate } from './model-delegate-interface';
import { ElementMap } from './element-map-interface';
import { ElementComparer } from './element-comparer-interface';

const PRIMITIVE_BOOLEAN_ID = "boolean_id";
const PRIMITIVE_INTEGER_ID = "integer_id";
const PRIMITIVE_REAL_ID = "real_id";
const PRIMITIVE_STRING_ID = "string_id";
const PRIMITIVE_OBJECT_ID = "object_id";
const PRIMITIVE_UNLIMITEDNATURAL_ID = "unlimitednatural_id";

export class DataToModelConverter
{
	private referencesToResolve: {target:any, data:any, resolvefn: (target:any, element:any) => void }[] = [];

	private createPrimitiveTypes(): elements.PrimitiveType[]
	{
		const result:elements.PrimitiveType[] = [];

		const booleanType = new classes.PrimitiveType(this.modelDelegate, null);
		booleanType.id = PRIMITIVE_BOOLEAN_ID;
		booleanType.name = 'boolean';
		result.push(booleanType);

		const integerType = new classes.PrimitiveType(this.modelDelegate, null);
		integerType.id = PRIMITIVE_INTEGER_ID;
		integerType.name = 'integer';
		result.push(integerType);

		const realType = new classes.PrimitiveType(this.modelDelegate, null);
		realType.id = PRIMITIVE_REAL_ID;
		realType.name = 'real';
		result.push(realType);

		const stringType = new classes.PrimitiveType(this.modelDelegate, null);
		stringType.id = PRIMITIVE_STRING_ID;
		stringType.name = 'string';
		result.push(stringType);

		const objectType = new classes.PrimitiveType(this.modelDelegate, null);
		objectType.id = PRIMITIVE_OBJECT_ID;
		objectType.name = 'object';
		result.push(objectType);

		const unlimitedNaturalType = new classes.PrimitiveType(this.modelDelegate, null);
		unlimitedNaturalType.id = PRIMITIVE_UNLIMITEDNATURAL_ID;
		unlimitedNaturalType.name = 'UnlimitedNatural';
		result.push(unlimitedNaturalType);
		return result;
	}

	private createElementType(elementData: data.ElementType): elements.ElementType
	{
		switch (elementData) // serialized as string
		{
			case 'class': return elements.ElementType.class;
			case 'stereotype': return elements.ElementType.stereotype;
			case 'property': return elements.ElementType.property;
			case 'package': return elements.ElementType.package;
			case 'profile': return elements.ElementType.profile;
			case 'dataType': return elements.ElementType.dataType;
			case 'primitiveType': return elements.ElementType.primitiveType;
			case 'parameter': return elements.ElementType.parameter;
			case 'operation': return elements.ElementType.operation;
			case 'model': return elements.ElementType.model;
			case 'literalUnlimitedNatural': return elements.ElementType.literalUnlimitedNatural;
			case 'literalString': return elements.ElementType.literalString;
			case 'literalReal': return elements.ElementType.literalReal;
			case 'literalNull': return elements.ElementType.literalNull;
			case 'literalInteger': return elements.ElementType.literalInteger;
			case 'literalBoolean': return elements.ElementType.literalBoolean;
			case 'interfaceRealization': return elements.ElementType.interfaceRealization;
			case 'interface': return elements.ElementType.interface;
			case 'generalization': return elements.ElementType.generalization;
			case 'enumerationLiteral': return elements.ElementType.enumerationLiteral;
			case 'enumeration': return elements.ElementType.enumeration;
			case 'comment': return elements.ElementType.comment;
			case 'association': return elements.ElementType.association;
			default: throw `Error reading model. Could not map ElementType value '${elementData}'.`;
		}
	}


    constructor(private elementMap: ElementMap, private modelDelegate: ModelDelegate, private elementComparer: ElementComparer) {
        const primitiveTypes = this.createPrimitiveTypes();
        primitiveTypes.forEach(t => {
            this.elementMap.addElement(t, null);
        });
    }

    /**
     * NOTE: this function must be edited in the partial template file.
     */
    private createElementId(elementId: string): string {
        return elementId;//  
	    // Obsolete: ids must be prefixed if we are loading a referenced document, because references to it 
	    // are prefixed with the document id    
        //return this.elementIdPrefix ? this.elementIdPrefix + '.' + elementId : elementId;
    }

    /**
     * NOTE: this function must be edited in the partial template file.
     */
    public convert(elementData: data.ModelData, profiles: elements.Profile[] | null): elements.Model {

        // this.elementIdPrefix = elementIdPrefix;

        // Deprecated: Extend prototypes with profile specific accessors
        // if (profiles) {
        //     ProfileExtender.applyProfiles(profiles);
        // }

        // Load the object tree recursively. This will fill elementMap and referencesToResolve.
        const model = this.createModel(elementData);
        
        // Now the object tree is loaded, set references between objects
        this.referencesToResolve.forEach((item) => {
            item.resolvefn.call(this, item.target, item.data);
        });
        this.referencesToResolve = []; // Release this list

        return model;
    }

    /**
     * NOTE: this function must be edited in the partial template file.
     */
    private addElementById(elementData: data.ElementData, element: elements.Element) {
        if ((!elementData.id || elementData.id.length === 0)) {
            // The following element types do not require an id 
            if (elementData.elementType !== 'enumerationLiteral' && elementData.elementType !== 'comment' && !DataToModelConverter.isValueSpecification(elementData.elementType)) {
                console.warn(`Mising id on element of type '${elementData.elementType}'.`);
            }
            return;
        }
        this.elementMap.addElement(element, elementData);
    }

    /**
     * Gets the id of the matching built-in primitive type if the element type is a literal type.
     * NOTE: this function must be edited in the partial template file.
     */
    private static getTypeIdIfLiteralType(elementType: data.ElementType): string | undefined {
        switch (elementType) {
            case 'literalBoolean':
                return PRIMITIVE_BOOLEAN_ID;
            case 'literalInteger':
                return PRIMITIVE_INTEGER_ID;
            case 'literalReal':
                return PRIMITIVE_REAL_ID;
            case 'literalString':
                return PRIMITIVE_STRING_ID;
            case 'literalUnlimitedNatural':
                return PRIMITIVE_UNLIMITEDNATURAL_ID;
            default:
                // TODO: deal with literalNull?			
                return undefined; // returns undefined because the result is assigned to a data property "type?: string;"
        }
    }

    /**
   * Custom function to create element properties from tagged values. 
   * NOTE: this function must be edited in the partial template file.
   */
    private mapTaggedValues(elementData: data.ElementData, element: elements.Element): void {
        if (!elementData.appliedStereotypes)
            return;

        // Get the stereotypes applied to this element. For each stereotype, get the meta properties.	
        // Note that we should not use element.appliedStereotypes because that data is not available
        // at this point.
        elementData.appliedStereotypes.forEach(stereotypeId => {
            // Lookup the stereotype by id. It should be indexed because the profiles are loaded first
            const st: elements.Stereotype | null = this.elementMap.getElementById<elements.Stereotype>(stereotypeId);
            if (!st) {
                return console.warn(`Element ${element.id} refers to undefined stereotype ${stereotypeId}.`);
            }
			(element as any)["stereotypeName"] = st.name; // always generated
            var stereotypeMetaProperties = st.getAllAttributes(); // stereotypes can inherit other stereotypes
            stereotypeMetaProperties.forEach(metaProperty => {
                if (element.hasOwnProperty(metaProperty.name))
                    return;

                //  Extend the element with the property. But determine the value first.				
                let valueSpecification: elements.ValueSpecification | null = null;
                const taggedValue = elementData.taggedValues ? elementData.taggedValues.find(v => v.definition === metaProperty.id) : null;
                if (taggedValue) {
                    valueSpecification = this.createValueSpecification(taggedValue.specification, element);
                }
                else if (metaProperty.defaultValue) {
                    valueSpecification = metaProperty.defaultValue;
                }
                (element as any)[metaProperty.name] = valueSpecification ? valueSpecification.getValue() : null;
            })
        });
    }
    
	private createVisibilityKind(elementData: data.VisibilityKind): elements.VisibilityKind
	{
		switch (elementData) // serialized as string
		{
			case 'public': return elements.VisibilityKind.public;
			case 'private': return elements.VisibilityKind.private;
			case 'protected': return elements.VisibilityKind.protected;
			case 'package': return elements.VisibilityKind.package;
			default: throw `Error reading model. Could not map VisibilityKind value '${elementData}'.`;
		}
	}

	private mapElement(elementData: data.ElementData, target: elements.Element, owner: elements.Element): void
	{
		target.id = this.createElementId(elementData.id);
		if (elementData.ownedComments) { target.ownedComments.push(...elementData.ownedComments.map((e) => { return this.createComment(e, target); }));}
		if (elementData.taggedValues) { target.taggedValues.push(...elementData.taggedValues.map((e) => { return this.createTaggedValueSpecification(e, target); }));}
		this.referencesToResolve.push({target:target, data:elementData, resolvefn: this.resolveElementReferences});
	}

	private resolveElementReferences(target: elements.Element, elementData: data.ElementData): void
	{
		if (elementData.appliedStereotypes) { target.appliedStereotypes.push(...this.elementMap.getElementsByIdList<elements.Stereotype>(elementData.appliedStereotypes));}
	}

	private mapNamedElement(elementData: data.NamedElementData, target: elements.NamedElement, owner: elements.Element): void
	{
		if (elementData.name) { target.name = elementData.name; }
		if (elementData.visibility) { target.visibility = this.createVisibilityKind(elementData.visibility);}
	}

	private mapTypedElement(elementData: data.TypedElementData, target: elements.TypedElement, owner: elements.Element): void
	{
		this.referencesToResolve.push({target:target, data:elementData, resolvefn: this.resolveTypedElementReferences});
	}

	private resolveTypedElementReferences(target: elements.TypedElement, elementData: data.TypedElementData): void
	{
		// Special case for TypedElement: if this is a literal specification, the type can be a predefined primitive.
		if (!elementData.type) {elementData.type = DataToModelConverter.getTypeIdIfLiteralType(elementData.elementType);}
		target.type = elementData.type ? this.elementMap.getElementById<elements.Type>(elementData.type) : null;
	}

	private createValueSpecification(elementData: data.ValueSpecificationData, owner: elements.Element): elements.ValueSpecification
	{
		switch (elementData.elementType)
		{
			case "literalUnlimitedNatural":
				return this.createLiteralUnlimitedNatural(<data.LiteralUnlimitedNaturalData>elementData, owner);
			case "literalString":
				return this.createLiteralString(<data.LiteralStringData>elementData, owner);
			case "literalReal":
				return this.createLiteralReal(<data.LiteralRealData>elementData, owner);
			case "literalNull":
				return this.createLiteralNull(<data.LiteralNullData>elementData, owner);
			case "literalInteger":
				return this.createLiteralInteger(<data.LiteralIntegerData>elementData, owner);
			case "literalBoolean":
				return this.createLiteralBoolean(<data.LiteralBooleanData>elementData, owner);
			default: throw `Error reading model. Could not map ValueSpecification of type ${elementData.elementType}.`;
		}
	}

	private static isValueSpecification(elementType: data.ElementType): boolean
	{
		switch (elementType)
		{
			case "literalUnlimitedNatural":
			case "literalString":
			case "literalReal":
			case "literalNull":
			case "literalInteger":
			case "literalBoolean":
				return true;
			default: return false;
		}
	}

	private mapPackageableElement(elementData: data.PackageableElementData, target: elements.PackageableElement, owner: elements.Element): void
	{
	}

	private createPackageableElement(elementData: data.PackageableElementData, owner: elements.Element): elements.PackageableElement
	{
		switch (elementData.elementType)
		{
			case "interface":
				return this.createInterface(<data.InterfaceData>elementData, owner);
			case "primitiveType":
				return this.createPrimitiveType(<data.PrimitiveTypeData>elementData, owner);
			case "enumeration":
				return this.createEnumeration(<data.EnumerationData>elementData, owner);
			case "dataType":
				return this.createDataType(<data.DataTypeData>elementData, owner);
			case "stereotype":
				return this.createStereotype(<data.StereotypeData>elementData, owner);
			case "class":
				return this.createClass(<data.ClassData>elementData, owner);
			case "association":
				return this.createAssociation(<data.AssociationData>elementData, owner);
			case "profile":
				return this.createProfile(<data.ProfileData>elementData, owner);
			case "package":
				return this.createPackage(<data.PackageData>elementData, owner);
			default: throw `Error reading model. Could not map PackageableElement of type ${elementData.elementType}.`;
		}
	}

	private static isPackageableElement(elementType: data.ElementType): boolean
	{
		switch (elementType)
		{
			case "interface":
			case "primitiveType":
			case "enumeration":
			case "dataType":
			case "stereotype":
			case "class":
			case "association":
			case "profile":
			case "package":
				return true;
			default: return false;
		}
	}

	private mapType(elementData: data.TypeData, target: elements.Type, owner: elements.Element): void
	{
		if (elementData.isInferred) { target.isInferred = elementData.isInferred; }
	}

	private mapTaggedValueSpecification(elementData: data.TaggedValueSpecificationData, target: elements.TaggedValueSpecification, owner: elements.Element): void
	{
		if (elementData.specification) { target.specification = this.createValueSpecification(elementData.specification, owner);}
		this.referencesToResolve.push({target:target, data:elementData, resolvefn: this.resolveTaggedValueSpecificationReferences});
	}

	private resolveTaggedValueSpecificationReferences(target: elements.TaggedValueSpecification, elementData: data.TaggedValueSpecificationData): void
	{
		if (!elementData.definition) console.error(`Unable to set property 'definition'. The following data is missing a 'definition' field: ${JSON.stringify(elementData)}.`);
		const definition = this.elementMap.getElementById<elements.Property>(elementData.definition);
		if (definition) { target.definition = definition } else console.error(`Unable to set property 'definition'. Property with id '${elementData.definition}' does not exist.`);
	}

	private createTaggedValueSpecification(elementData: data.TaggedValueSpecificationData, owner: elements.Element): elements.TaggedValueSpecification
	{
		const element = new classes.TaggedValueSpecification();
		this.mapTaggedValueSpecification(elementData, element, owner);
		return element;
	}

	private mapRedefinableElement(elementData: data.RedefinableElementData, target: elements.RedefinableElement, owner: elements.Element): void
	{
		if (elementData.isLeaf) { target.isLeaf = elementData.isLeaf; }
	}

	private mapClassifier(elementData: data.ClassifierData, target: elements.Classifier, owner: elements.Element): void
	{
		if (elementData.generalizations) { target.generalizations.push(...elementData.generalizations.map((e) => { return this.createGeneralization(e, target); }));}
		if (elementData.isAbstract) { target.isAbstract = elementData.isAbstract; }
		if (elementData.isFinalSpecialization) { target.isFinalSpecialization = elementData.isFinalSpecialization; }
	}

	private mapMultiplicityElement(elementData: data.MultiplicityElementData, target: elements.MultiplicityElement, owner: elements.Element): void
	{
		if (elementData.isOrdered) { target.isOrdered = elementData.isOrdered; }
		if (elementData.isUnique) { target.isUnique = elementData.isUnique; }
		if (elementData.lowerValue) { target.lowerValue = this.createValueSpecification(elementData.lowerValue, target);}
		if (elementData.upperValue) { target.upperValue = this.createValueSpecification(elementData.upperValue, target);}
	}

	private mapOrderedElement(elementData: data.OrderedElementData, target: elements.OrderedElement, owner: elements.Element): void
	{
		if (elementData.order) { target.order = elementData.order; }
	}

	private mapFeature(elementData: data.FeatureData, target: elements.Feature, owner: elements.Element): void
	{
		if (elementData.isStatic) { target.isStatic = elementData.isStatic; }
	}

	private mapStructuralFeature(elementData: data.StructuralFeatureData, target: elements.StructuralFeature, owner: elements.Element): void
	{
		if (elementData.isReadOnly) { target.isReadOnly = elementData.isReadOnly; }
	}

	private mapStereotypeExtension(elementData: data.StereotypeExtensionData, target: elements.StereotypeExtension, owner: elements.Element): void
	{
		if (elementData.isRequired) { target.isRequired = elementData.isRequired; }
		if (elementData.metaClass) { target.metaClass = this.createElementType(elementData.metaClass);}
	}

	private createStereotypeExtension(elementData: data.StereotypeExtensionData, owner: elements.Element): elements.StereotypeExtension
	{
		const element = new classes.StereotypeExtension();
		this.mapStereotypeExtension(elementData, element, owner);
		return element;
	}

	private mapMemberedClassifier(elementData: data.MemberedClassifierData, target: elements.MemberedClassifier, owner: elements.Element): void
	{
		if (elementData.ownedAttributes) { target.ownedAttributes.push(...elementData.ownedAttributes.map((e) => { return this.createProperty(e, target); }).sort(this.elementComparer.compareOrderedElements));}
		if (elementData.ownedOperations) { target.ownedOperations.push(...elementData.ownedOperations.map((e) => { return this.createOperation(e, target); }).sort(this.elementComparer.compareOrderedElements));}
	}

	private mapBehavioredClassifier(elementData: data.BehavioredClassifierData, target: elements.BehavioredClassifier, owner: elements.Element): void
	{
		if (elementData.interfaceRealizations) { target.interfaceRealizations.push(...elementData.interfaceRealizations.map((e) => { return this.createInterfaceRealization(e, target); }));}
	}

	private mapClass(elementData: data.ClassData, target: elements.Class, owner: elements.Element): void
	{
		if (elementData.isActive) { target.isActive = elementData.isActive; }
	}

	private createClass(elementData: data.ClassData, owner: elements.Element): elements.Class
	{
		const element = new classes.Class(this.modelDelegate, owner);
		this.mapElement(elementData, element, element);
		this.mapNamedElement(elementData, element, element);
		this.mapPackageableElement(elementData, element, element);
		this.mapRedefinableElement(elementData, element, element);
		this.mapType(elementData, element, element);
		this.mapClassifier(elementData, element, element);
		this.mapMemberedClassifier(elementData, element, element);
		this.mapBehavioredClassifier(elementData, element, element);
		this.mapClass(elementData, element, element);
		this.mapTaggedValues(elementData, element); // added by code generation
		this.addElementById(elementData, element);
		return element;
	}

	private mapStereotype(elementData: data.StereotypeData, target: elements.Stereotype, owner: elements.Element): void
	{
		if (elementData.extends) { target.extends.push(...elementData.extends.map((e) => { return this.createStereotypeExtension(e, target); }));}
		if (elementData.safeName) { target.safeName = elementData.safeName; }
	}

	private createStereotype(elementData: data.StereotypeData, owner: elements.Element): elements.Stereotype
	{
		const element = new classes.Stereotype(this.modelDelegate, owner);
		this.mapElement(elementData, element, element);
		this.mapNamedElement(elementData, element, element);
		this.mapPackageableElement(elementData, element, element);
		this.mapRedefinableElement(elementData, element, element);
		this.mapType(elementData, element, element);
		this.mapClassifier(elementData, element, element);
		this.mapMemberedClassifier(elementData, element, element);
		this.mapBehavioredClassifier(elementData, element, element);
		this.mapClass(elementData, element, element);
		this.mapStereotype(elementData, element, element);
		this.mapTaggedValues(elementData, element); // added by code generation
		this.addElementById(elementData, element);
		return element;
	}

	private mapProperty(elementData: data.PropertyData, target: elements.Property, owner: elements.Element): void
	{
		if (elementData.aggregation) { target.aggregation = this.createAggregationKind(elementData.aggregation);}
		if (elementData.defaultValue) { target.defaultValue = this.createValueSpecification(elementData.defaultValue, target);}
		if (elementData.isDerived) { target.isDerived = elementData.isDerived; }
		if (elementData.isDerivedUnion) { target.isDerivedUnion = elementData.isDerivedUnion; }
		if (elementData.isID) { target.isID = elementData.isID; }
		if (elementData.isNavigable) { target.isNavigable = elementData.isNavigable; }
	}

	private createProperty(elementData: data.PropertyData, owner: elements.Element): elements.Property
	{
		const element = new classes.Property(this.modelDelegate, owner);
		this.mapElement(elementData, element, element);
		this.mapNamedElement(elementData, element, element);
		this.mapOrderedElement(elementData, element, element);
		this.mapRedefinableElement(elementData, element, element);
		this.mapTypedElement(elementData, element, element);
		this.mapMultiplicityElement(elementData, element, element);
		this.mapFeature(elementData, element, element);
		this.mapStructuralFeature(elementData, element, element);
		this.mapProperty(elementData, element, element);
		this.mapTaggedValues(elementData, element); // added by code generation
		this.addElementById(elementData, element);
		return element;
	}

	private mapPackage(elementData: data.PackageData, target: elements.Package, owner: elements.Element): void
	{
		if (elementData.isNamespaceRoot) { target.isNamespaceRoot = elementData.isNamespaceRoot; }
		if (elementData.packagedElements) { target.packagedElements.push(...elementData.packagedElements.map((e) => { return this.createPackageableElement(e, target); }).sort(this.elementComparer.comparePackageableElements));}
		this.referencesToResolve.push({target:target, data:elementData, resolvefn: this.resolvePackageReferences});
	}

	private resolvePackageReferences(target: elements.Package, elementData: data.PackageData): void
	{
		if (elementData.appliedProfiles) { target.appliedProfiles.push(...this.elementMap.getElementsByIdList<elements.Profile>(elementData.appliedProfiles));}
	}

	private createPackage(elementData: data.PackageData, owner: elements.Element): elements.Package
	{
		const element = new classes.Package(this.modelDelegate, owner);
		this.mapElement(elementData, element, element);
		this.mapNamedElement(elementData, element, element);
		this.mapPackageableElement(elementData, element, element);
		this.mapPackage(elementData, element, element);
		this.mapTaggedValues(elementData, element); // added by code generation
		this.addElementById(elementData, element);
		return element;
	}

	private mapProfile(elementData: data.ProfileData, target: elements.Profile, owner: elements.Element): void
	{
		if (elementData.safeName) { target.safeName = elementData.safeName; }
	}

	private createProfile(elementData: data.ProfileData, owner: elements.Element): elements.Profile
	{
		const element = new classes.Profile(this.modelDelegate, owner);
		this.mapElement(elementData, element, element);
		this.mapNamedElement(elementData, element, element);
		this.mapPackageableElement(elementData, element, element);
		this.mapPackage(elementData, element, element);
		this.mapProfile(elementData, element, element);
		this.mapTaggedValues(elementData, element); // added by code generation
		this.addElementById(elementData, element);
		return element;
	}

	private createDataType(elementData: data.DataTypeData, owner: elements.Element): elements.DataType
	{
		const element = new classes.DataType(this.modelDelegate, owner);
		this.mapElement(elementData, element, element);
		this.mapNamedElement(elementData, element, element);
		this.mapPackageableElement(elementData, element, element);
		this.mapRedefinableElement(elementData, element, element);
		this.mapType(elementData, element, element);
		this.mapClassifier(elementData, element, element);
		this.mapMemberedClassifier(elementData, element, element);
		this.mapTaggedValues(elementData, element); // added by code generation
		this.addElementById(elementData, element);
		return element;
	}

	private createPrimitiveType(elementData: data.PrimitiveTypeData, owner: elements.Element): elements.PrimitiveType
	{
		const element = new classes.PrimitiveType(this.modelDelegate, owner);
		this.mapElement(elementData, element, element);
		this.mapNamedElement(elementData, element, element);
		this.mapPackageableElement(elementData, element, element);
		this.mapRedefinableElement(elementData, element, element);
		this.mapType(elementData, element, element);
		this.mapClassifier(elementData, element, element);
		this.mapMemberedClassifier(elementData, element, element);
		this.mapTaggedValues(elementData, element); // added by code generation
		this.addElementById(elementData, element);
		return element;
	}

	private createParameterDirectionKind(elementData: data.ParameterDirectionKind): elements.ParameterDirectionKind
	{
		switch (elementData) // serialized as string
		{
			case 'in': return elements.ParameterDirectionKind.in;
			case 'inout': return elements.ParameterDirectionKind.inout;
			case 'out': return elements.ParameterDirectionKind.out;
			case 'return': return elements.ParameterDirectionKind.return;
			default: throw `Error reading model. Could not map ParameterDirectionKind value '${elementData}'.`;
		}
	}

	private mapParameter(elementData: data.ParameterData, target: elements.Parameter, owner: elements.Element): void
	{
		if (elementData.defaultValue) { target.defaultValue = this.createValueSpecification(elementData.defaultValue, target);}
		if (elementData.direction) { target.direction = this.createParameterDirectionKind(elementData.direction);}
		if (elementData.isException) { target.isException = elementData.isException; }
		if (elementData.isStream) { target.isStream = elementData.isStream; }
	}

	private createParameter(elementData: data.ParameterData, owner: elements.Element): elements.Parameter
	{
		const element = new classes.Parameter(this.modelDelegate, owner);
		this.mapElement(elementData, element, element);
		this.mapNamedElement(elementData, element, element);
		this.mapOrderedElement(elementData, element, element);
		this.mapMultiplicityElement(elementData, element, element);
		this.mapTypedElement(elementData, element, element);
		this.mapParameter(elementData, element, element);
		this.mapTaggedValues(elementData, element); // added by code generation
		this.addElementById(elementData, element);
		return element;
	}

	private mapBehavioralFeature(elementData: data.BehavioralFeatureData, target: elements.BehavioralFeature, owner: elements.Element): void
	{
		if (elementData.isAbstract) { target.isAbstract = elementData.isAbstract; }
		if (elementData.ownedParameters) { target.ownedParameters.push(...elementData.ownedParameters.map((e) => { return this.createParameter(e, target); }).sort(this.elementComparer.compareOrderedElements));}
	}

	private mapOperation(elementData: data.OperationData, target: elements.Operation, owner: elements.Element): void
	{
		if (elementData.isConstructor) { target.isConstructor = elementData.isConstructor; }
		if (elementData.isQuery) { target.isQuery = elementData.isQuery; }
	}

	private createOperation(elementData: data.OperationData, owner: elements.Element): elements.Operation
	{
		const element = new classes.Operation(this.modelDelegate, owner);
		this.mapElement(elementData, element, element);
		this.mapNamedElement(elementData, element, element);
		this.mapOrderedElement(elementData, element, element);
		this.mapRedefinableElement(elementData, element, element);
		this.mapFeature(elementData, element, element);
		this.mapBehavioralFeature(elementData, element, element);
		this.mapOperation(elementData, element, element);
		this.mapTaggedValues(elementData, element); // added by code generation
		this.addElementById(elementData, element);
		return element;
	}

	private createModel(elementData: data.ModelData): elements.Model
	{
		const element = new classes.Model(this.modelDelegate, null);
		this.mapElement(elementData, element, element);
		this.mapNamedElement(elementData, element, element);
		this.mapPackageableElement(elementData, element, element);
		this.mapPackage(elementData, element, element);
		this.mapTaggedValues(elementData, element); // added by code generation
		this.addElementById(elementData, element);
		return element;
	}

	private mapLiteralUnlimitedNatural(elementData: data.LiteralUnlimitedNaturalData, target: elements.LiteralUnlimitedNatural, owner: elements.Element): void
	{
		if (elementData.value) { target.value = new elements.UnlimitedNatural(elementData.value); }
	}

	private createLiteralUnlimitedNatural(elementData: data.LiteralUnlimitedNaturalData, owner: elements.Element): elements.LiteralUnlimitedNatural
	{
		const element = new classes.LiteralUnlimitedNatural(this.modelDelegate, owner);
		this.mapElement(elementData, element, element);
		this.mapNamedElement(elementData, element, element);
		this.mapTypedElement(elementData, element, element);
		this.mapLiteralUnlimitedNatural(elementData, element, element);
		this.mapTaggedValues(elementData, element); // added by code generation
		this.addElementById(elementData, element);
		return element;
	}

	private mapLiteralString(elementData: data.LiteralStringData, target: elements.LiteralString, owner: elements.Element): void
	{
		if (elementData.value) { target.value = elementData.value; }
	}

	private createLiteralString(elementData: data.LiteralStringData, owner: elements.Element): elements.LiteralString
	{
		const element = new classes.LiteralString(this.modelDelegate, owner);
		this.mapElement(elementData, element, element);
		this.mapNamedElement(elementData, element, element);
		this.mapTypedElement(elementData, element, element);
		this.mapLiteralString(elementData, element, element);
		this.mapTaggedValues(elementData, element); // added by code generation
		this.addElementById(elementData, element);
		return element;
	}

	private mapLiteralReal(elementData: data.LiteralRealData, target: elements.LiteralReal, owner: elements.Element): void
	{
		if (elementData.value) { target.value = elementData.value; }
	}

	private createLiteralReal(elementData: data.LiteralRealData, owner: elements.Element): elements.LiteralReal
	{
		const element = new classes.LiteralReal(this.modelDelegate, owner);
		this.mapElement(elementData, element, element);
		this.mapNamedElement(elementData, element, element);
		this.mapTypedElement(elementData, element, element);
		this.mapLiteralReal(elementData, element, element);
		this.mapTaggedValues(elementData, element); // added by code generation
		this.addElementById(elementData, element);
		return element;
	}

	private createLiteralNull(elementData: data.LiteralNullData, owner: elements.Element): elements.LiteralNull
	{
		const element = new classes.LiteralNull(this.modelDelegate, owner);
		this.mapElement(elementData, element, element);
		this.mapNamedElement(elementData, element, element);
		this.mapTypedElement(elementData, element, element);
		this.mapTaggedValues(elementData, element); // added by code generation
		this.addElementById(elementData, element);
		return element;
	}

	private mapLiteralInteger(elementData: data.LiteralIntegerData, target: elements.LiteralInteger, owner: elements.Element): void
	{
		if (elementData.value) { target.value = elementData.value; }
	}

	private createLiteralInteger(elementData: data.LiteralIntegerData, owner: elements.Element): elements.LiteralInteger
	{
		const element = new classes.LiteralInteger(this.modelDelegate, owner);
		this.mapElement(elementData, element, element);
		this.mapNamedElement(elementData, element, element);
		this.mapTypedElement(elementData, element, element);
		this.mapLiteralInteger(elementData, element, element);
		this.mapTaggedValues(elementData, element); // added by code generation
		this.addElementById(elementData, element);
		return element;
	}

	private mapLiteralBoolean(elementData: data.LiteralBooleanData, target: elements.LiteralBoolean, owner: elements.Element): void
	{
		if (elementData.value) { target.value = elementData.value; }
	}

	private createLiteralBoolean(elementData: data.LiteralBooleanData, owner: elements.Element): elements.LiteralBoolean
	{
		const element = new classes.LiteralBoolean(this.modelDelegate, owner);
		this.mapElement(elementData, element, element);
		this.mapNamedElement(elementData, element, element);
		this.mapTypedElement(elementData, element, element);
		this.mapLiteralBoolean(elementData, element, element);
		this.mapTaggedValues(elementData, element); // added by code generation
		this.addElementById(elementData, element);
		return element;
	}

	private mapInterfaceRealization(elementData: data.InterfaceRealizationData, target: elements.InterfaceRealization, owner: elements.Element): void
	{
		this.referencesToResolve.push({target:target, data:elementData, resolvefn: this.resolveInterfaceRealizationReferences});
	}

	private resolveInterfaceRealizationReferences(target: elements.InterfaceRealization, elementData: data.InterfaceRealizationData): void
	{
		if (!elementData.contract) console.error(`Unable to set property 'contract'. The following data is missing a 'contract' field: ${JSON.stringify(elementData)}.`);
		const contract = this.elementMap.getElementById<elements.Interface>(elementData.contract);
		if (contract) { target.contract = contract } else console.error(`Unable to set property 'contract'. Interface with id '${elementData.contract}' does not exist.`);
	}

	private createInterfaceRealization(elementData: data.InterfaceRealizationData, owner: elements.Element): elements.InterfaceRealization
	{
		const element = new classes.InterfaceRealization(this.modelDelegate, owner);
		this.mapElement(elementData, element, element);
		this.mapInterfaceRealization(elementData, element, element);
		this.mapTaggedValues(elementData, element); // added by code generation
		this.addElementById(elementData, element);
		return element;
	}

	private createInterface(elementData: data.InterfaceData, owner: elements.Element): elements.Interface
	{
		const element = new classes.Interface(this.modelDelegate, owner);
		this.mapElement(elementData, element, element);
		this.mapNamedElement(elementData, element, element);
		this.mapPackageableElement(elementData, element, element);
		this.mapRedefinableElement(elementData, element, element);
		this.mapType(elementData, element, element);
		this.mapClassifier(elementData, element, element);
		this.mapMemberedClassifier(elementData, element, element);
		this.mapTaggedValues(elementData, element); // added by code generation
		this.addElementById(elementData, element);
		return element;
	}

	private mapGeneralization(elementData: data.GeneralizationData, target: elements.Generalization, owner: elements.Element): void
	{
		if (elementData.isSubstitutable) { target.isSubstitutable = elementData.isSubstitutable; }
		this.referencesToResolve.push({target:target, data:elementData, resolvefn: this.resolveGeneralizationReferences});
	}

	private resolveGeneralizationReferences(target: elements.Generalization, elementData: data.GeneralizationData): void
	{
		if (!elementData.general) console.error(`Unable to set property 'general'. The following data is missing a 'general' field: ${JSON.stringify(elementData)}.`);
		const general = this.elementMap.getElementById<elements.Classifier>(elementData.general);
		if (general) { target.general = general } else console.error(`Unable to set property 'general'. Classifier with id '${elementData.general}' does not exist.`);
	}

	private createGeneralization(elementData: data.GeneralizationData, owner: elements.Element): elements.Generalization
	{
		const element = new classes.Generalization(this.modelDelegate, owner);
		this.mapElement(elementData, element, element);
		this.mapGeneralization(elementData, element, element);
		this.mapTaggedValues(elementData, element); // added by code generation
		this.addElementById(elementData, element);
		return element;
	}

	private mapEnumerationLiteral(elementData: data.EnumerationLiteralData, target: elements.EnumerationLiteral, owner: elements.Element): void
	{
		if (elementData.specification) { target.specification = this.createValueSpecification(elementData.specification, target);}
	}

	private createEnumerationLiteral(elementData: data.EnumerationLiteralData, owner: elements.Element): elements.EnumerationLiteral
	{
		const element = new classes.EnumerationLiteral(this.modelDelegate, owner);
		this.mapElement(elementData, element, element);
		this.mapOrderedElement(elementData, element, element);
		this.mapNamedElement(elementData, element, element);
		this.mapEnumerationLiteral(elementData, element, element);
		this.mapTaggedValues(elementData, element); // added by code generation
		this.addElementById(elementData, element);
		return element;
	}

	private mapEnumeration(elementData: data.EnumerationData, target: elements.Enumeration, owner: elements.Element): void
	{
		if (elementData.ownedLiterals) { target.ownedLiterals.push(...elementData.ownedLiterals.map((e) => { return this.createEnumerationLiteral(e, target); }).sort(this.elementComparer.compareOrderedElements));}
		this.referencesToResolve.push({target:target, data:elementData, resolvefn: this.resolveEnumerationReferences});
	}

	private resolveEnumerationReferences(target: elements.Enumeration, elementData: data.EnumerationData): void
	{
		target.baseType = elementData.baseType ? this.elementMap.getElementById<elements.Type>(elementData.baseType) : null;
	}

	private createEnumeration(elementData: data.EnumerationData, owner: elements.Element): elements.Enumeration
	{
		const element = new classes.Enumeration(this.modelDelegate, owner);
		this.mapElement(elementData, element, element);
		this.mapNamedElement(elementData, element, element);
		this.mapPackageableElement(elementData, element, element);
		this.mapRedefinableElement(elementData, element, element);
		this.mapType(elementData, element, element);
		this.mapClassifier(elementData, element, element);
		this.mapMemberedClassifier(elementData, element, element);
		this.mapEnumeration(elementData, element, element);
		this.mapTaggedValues(elementData, element); // added by code generation
		this.addElementById(elementData, element);
		return element;
	}

	private mapDocumentReference(elementData: data.DocumentReferenceData, target: elements.DocumentReference, owner: elements.Element): void
	{
		if (elementData.location) { target.location = this.createDocumentLocationKind(elementData.location);}
		if (elementData.name) { target.name = elementData.name; }
		if (elementData.path) { target.path = elementData.path; }
	}

	private createDocumentReference(elementData: data.DocumentReferenceData, owner: elements.Element): elements.DocumentReference
	{
		const element = new classes.DocumentReference();
		this.mapDocumentReference(elementData, element, owner);
		return element;
	}

	private createDocumentLocationKind(elementData: data.DocumentLocationKind): elements.DocumentLocationKind
	{
		switch (elementData) // serialized as string
		{
			case 'local': return elements.DocumentLocationKind.local;
			case 'npm': return elements.DocumentLocationKind.npm;
			default: throw `Error reading model. Could not map DocumentLocationKind value '${elementData}'.`;
		}
	}

	private mapComment(elementData: data.CommentData, target: elements.Comment, owner: elements.Element): void
	{
		if (elementData.body) { target.body = elementData.body; }
	}

	private createComment(elementData: data.CommentData, owner: elements.Element): elements.Comment
	{
		const element = new classes.Comment(this.modelDelegate, owner);
		this.mapElement(elementData, element, element);
		this.mapComment(elementData, element, element);
		this.mapTaggedValues(elementData, element); // added by code generation
		this.addElementById(elementData, element);
		return element;
	}

	private mapAssociation(elementData: data.AssociationData, target: elements.Association, owner: elements.Element): void
	{
		if (elementData.ownedEnds) { target.ownedEnds.push(...elementData.ownedEnds.map((e) => { return this.createProperty(e, target); }).sort(this.elementComparer.compareOrderedElements));}
		this.referencesToResolve.push({target:target, data:elementData, resolvefn: this.resolveAssociationReferences});
	}

	private resolveAssociationReferences(target: elements.Association, elementData: data.AssociationData): void
	{
		if (elementData.memberEnds) { target.memberEnds.push(...this.elementMap.getElementsByIdList<elements.Property>(elementData.memberEnds));}
	}

	private createAssociation(elementData: data.AssociationData, owner: elements.Element): elements.Association
	{
		const element = new classes.Association(this.modelDelegate, owner);
		this.mapElement(elementData, element, element);
		this.mapNamedElement(elementData, element, element);
		this.mapPackageableElement(elementData, element, element);
		this.mapRedefinableElement(elementData, element, element);
		this.mapType(elementData, element, element);
		this.mapClassifier(elementData, element, element);
		this.mapAssociation(elementData, element, element);
		this.mapTaggedValues(elementData, element); // added by code generation
		this.addElementById(elementData, element);
		return element;
	}

	private createAggregationKind(elementData: data.AggregationKind): elements.AggregationKind
	{
		switch (elementData) // serialized as string
		{
			case 'none': return elements.AggregationKind.none;
			case 'shared': return elements.AggregationKind.shared;
			case 'composite': return elements.AggregationKind.composite;
			default: throw `Error reading model. Could not map AggregationKind value '${elementData}'.`;
		}
	}

}
