/*
* Copyright (c) 2020 Yellicode
*
* This Source Code Form is subject to the terms of the Mozilla Public
* License, v. 2.0. If a copy of the MPL was not distributed with this
* file, You can obtain one at http://mozilla.org/MPL/2.0/.
*/

/**
* This code was generated by a tool.
* 
* Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
*/

import * as elements from './interfaces';


export interface ClassProperties {
	/**
	* The name of the NamedElement.
	*/
	name: string;
	/**
	* Determines whether and how the NamedElement is visible outside its owning Namespace.
	*/
	visibility?: elements.VisibilityKind;
	/**
	* If true, the type was inferred by a tool, for example during data import. An inferred type is never
	* owned by any Package.
	*/
	isInferred?: boolean;
	/**
	* Indicates whether it is possible to further redefine a RedefinableElement. If the value is true,
	* then it is not possible to further redefine the RedefinableElement.
	*/
	isLeaf?: boolean;
	/**
	* If true, the Classifier can only be instantiated by instantiating one of its specializations. An
	* abstract Classifier is intended to be used by other Classifiers e.g., as the target of Associations
	* or Generalizations.
	*/
	isAbstract?: boolean;
	/**
	* If true, the Classifier cannot be specialized.
	*/
	isFinalSpecialization?: boolean;
	/**
	* Determines whether an object specified by this Class is active or not. If true, then the owning
	* Class is referred to as an active Class. If false, then such a Class is referred to as a passive
	* Class.
	*/
	isActive?: boolean;
}

export interface PropertyProperties {
	/**
	* The name of the NamedElement.
	*/
	name: string;
	/**
	* Determines whether and how the NamedElement is visible outside its owning Namespace.
	*/
	visibility?: elements.VisibilityKind;
	/**
	* Indicates whether it is possible to further redefine a RedefinableElement. If the value is true,
	* then it is not possible to further redefine the RedefinableElement.
	*/
	isLeaf?: boolean;
	/**
	* Gets or set the sort order of the element if it is part of a collection. The value is 0 for elements
	* to which no particular ordering applies. Elements with a lower order come before elements with a
	* higher order.
	*/
	order?: number;
	/**
	* Specifies whether this Feature characterizes individual instances classified by the Classifier
	* (false) or the Classifier itself (true).
	*/
	isStatic?: boolean;
	/**
	* For a multivalued multiplicity, this attribute specifies whether the values in an instantiation of
	* this MultiplicityElement are sequentially ordered.
	*/
	isOrdered?: boolean;
	/**
	* For a multivalued multiplicity, this attributes specifies whether the values in an instantiation of
	* this MultiplicityElement are unique.
	*/
	isUnique?: boolean;
	/**
	* The type of the TypedElement.
	*/
	type?: elements.Type;
	/**
	* If isReadOnly is true, the StructuralFeature may not be written to after initialization.
	*/
	isReadOnly?: boolean;
	/**
	* 
	*/
	aggregation?: elements.AggregationKind;
	/**
	* The Association of which this Property is a member, if any.
	*/
	association?: elements.Association;
	/**
	* Specifies whether the property is derived as the union of all of the Properties that are constrained
	* to subset it.
	*/
	isDerived?: boolean;
	/**
	* Specifies whether the property is derived as the union of all of the Properties that are constrained
	* to subset it.
	*/
	isDerivedUnion?: boolean;
	/**
	* True indicates this property can be used to uniquely identify an instance of the containing Class.
	*/
	isID?: boolean;
	/**
	* Returns true if the Property is owned by a classifier or is included in the NavigableOwnedEnds of an
	* association.
	*/
	isNavigable?: boolean;
}

export interface PackageProperties {
	/**
	* The name of the NamedElement.
	*/
	name: string;
	/**
	* Determines whether and how the NamedElement is visible outside its owning Namespace.
	*/
	visibility?: elements.VisibilityKind;
	/**
	* Denotes where the namespace structure for your class model starts; all nested packages below a
	* namespace root will form the namespace hierarchy for contained types.
	*/
	isNamespaceRoot?: boolean;
}

export interface DataTypeProperties {
	/**
	* The name of the NamedElement.
	*/
	name: string;
	/**
	* Determines whether and how the NamedElement is visible outside its owning Namespace.
	*/
	visibility?: elements.VisibilityKind;
	/**
	* If true, the type was inferred by a tool, for example during data import. An inferred type is never
	* owned by any Package.
	*/
	isInferred?: boolean;
	/**
	* Indicates whether it is possible to further redefine a RedefinableElement. If the value is true,
	* then it is not possible to further redefine the RedefinableElement.
	*/
	isLeaf?: boolean;
	/**
	* If true, the Classifier can only be instantiated by instantiating one of its specializations. An
	* abstract Classifier is intended to be used by other Classifiers e.g., as the target of Associations
	* or Generalizations.
	*/
	isAbstract?: boolean;
	/**
	* If true, the Classifier cannot be specialized.
	*/
	isFinalSpecialization?: boolean;
}

export interface PrimitiveTypeProperties {
	/**
	* The name of the NamedElement.
	*/
	name: string;
	/**
	* Determines whether and how the NamedElement is visible outside its owning Namespace.
	*/
	visibility?: elements.VisibilityKind;
	/**
	* If true, the type was inferred by a tool, for example during data import. An inferred type is never
	* owned by any Package.
	*/
	isInferred?: boolean;
	/**
	* Indicates whether it is possible to further redefine a RedefinableElement. If the value is true,
	* then it is not possible to further redefine the RedefinableElement.
	*/
	isLeaf?: boolean;
	/**
	* If true, the Classifier can only be instantiated by instantiating one of its specializations. An
	* abstract Classifier is intended to be used by other Classifiers e.g., as the target of Associations
	* or Generalizations.
	*/
	isAbstract?: boolean;
	/**
	* If true, the Classifier cannot be specialized.
	*/
	isFinalSpecialization?: boolean;
}

export interface ParameterProperties {
	/**
	* The name of the NamedElement.
	*/
	name: string;
	/**
	* Determines whether and how the NamedElement is visible outside its owning Namespace.
	*/
	visibility?: elements.VisibilityKind;
	/**
	* The type of the TypedElement.
	*/
	type?: elements.Type;
	/**
	* For a multivalued multiplicity, this attribute specifies whether the values in an instantiation of
	* this MultiplicityElement are sequentially ordered.
	*/
	isOrdered?: boolean;
	/**
	* For a multivalued multiplicity, this attributes specifies whether the values in an instantiation of
	* this MultiplicityElement are unique.
	*/
	isUnique?: boolean;
	/**
	* Gets or set the sort order of the element if it is part of a collection. The value is 0 for elements
	* to which no particular ordering applies. Elements with a lower order come before elements with a
	* higher order.
	*/
	order?: number;
	/**
	* 
	*/
	direction?: elements.ParameterDirectionKind;
	/**
	* Tells whether an output parameter may emit a value to the exclusion of the other outputs.
	*/
	isException?: boolean;
	/**
	* Tells whether an input parameter may accept values while its behavior is executing, or whether an
	* output parameter may post values while the behavior is executing.
	*/
	isStream?: boolean;
}

export interface OperationProperties {
	/**
	* The name of the NamedElement.
	*/
	name: string;
	/**
	* Determines whether and how the NamedElement is visible outside its owning Namespace.
	*/
	visibility?: elements.VisibilityKind;
	/**
	* Indicates whether it is possible to further redefine a RedefinableElement. If the value is true,
	* then it is not possible to further redefine the RedefinableElement.
	*/
	isLeaf?: boolean;
	/**
	* Gets or set the sort order of the element if it is part of a collection. The value is 0 for elements
	* to which no particular ordering applies. Elements with a lower order come before elements with a
	* higher order.
	*/
	order?: number;
	/**
	* Specifies whether this Feature characterizes individual instances classified by the Classifier
	* (false) or the Classifier itself (true).
	*/
	isStatic?: boolean;
	/**
	* If true, then the BehavioralFeature does not have an implementation, and one must be supplied by a
	* more specific Classifier. If false, the BehavioralFeature must have an implementation in the
	* Classifier or one must be inherited.
	*/
	isAbstract?: boolean;
	/**
	* Specifies if the operation is a class constructor.
	*/
	isConstructor?: boolean;
	/**
	* Specifies whether an execution of the BehavioralFeature leaves the state of the system unchanged
	* (isQuery=true) or whether side effects may occur (isQuery=false).
	*/
	isQuery?: boolean;
}

export interface ModelProperties {
	/**
	* The name of the NamedElement.
	*/
	name: string;
	/**
	* Determines whether and how the NamedElement is visible outside its owning Namespace.
	*/
	visibility?: elements.VisibilityKind;
	/**
	* Denotes where the namespace structure for your class model starts; all nested packages below a
	* namespace root will form the namespace hierarchy for contained types.
	*/
	isNamespaceRoot?: boolean;
}

export interface InterfaceRealizationProperties {
	/**
	* References the Interface specifying the conformance contract.
	*/
	contract: elements.Interface;
}

export interface InterfaceProperties {
	/**
	* The name of the NamedElement.
	*/
	name: string;
	/**
	* Determines whether and how the NamedElement is visible outside its owning Namespace.
	*/
	visibility?: elements.VisibilityKind;
	/**
	* If true, the type was inferred by a tool, for example during data import. An inferred type is never
	* owned by any Package.
	*/
	isInferred?: boolean;
	/**
	* Indicates whether it is possible to further redefine a RedefinableElement. If the value is true,
	* then it is not possible to further redefine the RedefinableElement.
	*/
	isLeaf?: boolean;
	/**
	* If true, the Classifier can only be instantiated by instantiating one of its specializations. An
	* abstract Classifier is intended to be used by other Classifiers e.g., as the target of Associations
	* or Generalizations.
	*/
	isAbstract?: boolean;
	/**
	* If true, the Classifier cannot be specialized.
	*/
	isFinalSpecialization?: boolean;
}

export interface GeneralizationProperties {
	/**
	* The general classifier in the Generalization relationship.
	*/
	general: elements.Classifier;
	/**
	* Indicates whether the specific Classifier can be used wherever the general Classifier can be used.
	* If true, the execution traces of the specific Classifier shall be a superset of the execution traces
	* of the general Classifier. If false, there is no such constraint on execution traces. If unset, the
	* modeler has not stated whether there is such a constraint or not.
	*/
	isSubstitutable?: boolean;
}

export interface EnumerationLiteralProperties {
	/**
	* The name of the NamedElement.
	*/
	name: string;
	/**
	* Determines whether and how the NamedElement is visible outside its owning Namespace.
	*/
	visibility?: elements.VisibilityKind;
	/**
	* Gets or set the sort order of the element if it is part of a collection. The value is 0 for elements
	* to which no particular ordering applies. Elements with a lower order come before elements with a
	* higher order.
	*/
	order?: number;
}

export interface EnumerationProperties {
	/**
	* The name of the NamedElement.
	*/
	name: string;
	/**
	* Determines whether and how the NamedElement is visible outside its owning Namespace.
	*/
	visibility?: elements.VisibilityKind;
	/**
	* If true, the type was inferred by a tool, for example during data import. An inferred type is never
	* owned by any Package.
	*/
	isInferred?: boolean;
	/**
	* Indicates whether it is possible to further redefine a RedefinableElement. If the value is true,
	* then it is not possible to further redefine the RedefinableElement.
	*/
	isLeaf?: boolean;
	/**
	* If true, the Classifier can only be instantiated by instantiating one of its specializations. An
	* abstract Classifier is intended to be used by other Classifiers e.g., as the target of Associations
	* or Generalizations.
	*/
	isAbstract?: boolean;
	/**
	* If true, the Classifier cannot be specialized.
	*/
	isFinalSpecialization?: boolean;
	/**
	* Gets the base type of the enumeration. For most programming language, this is an integral type if
	* not specified.
	*/
	baseType?: elements.Type;
}

export interface CommentProperties {
	/**
	* 
	*/
	body?: string;
}

export interface AssociationProperties {
	/**
	* The name of the NamedElement.
	*/
	name: string;
	/**
	* Determines whether and how the NamedElement is visible outside its owning Namespace.
	*/
	visibility?: elements.VisibilityKind;
	/**
	* If true, the type was inferred by a tool, for example during data import. An inferred type is never
	* owned by any Package.
	*/
	isInferred?: boolean;
	/**
	* Indicates whether it is possible to further redefine a RedefinableElement. If the value is true,
	* then it is not possible to further redefine the RedefinableElement.
	*/
	isLeaf?: boolean;
	/**
	* If true, the Classifier can only be instantiated by instantiating one of its specializations. An
	* abstract Classifier is intended to be used by other Classifiers e.g., as the target of Associations
	* or Generalizations.
	*/
	isAbstract?: boolean;
	/**
	* If true, the Classifier cannot be specialized.
	*/
	isFinalSpecialization?: boolean;
}

export interface ClassEditable extends elements.Class {
	addGeneralization(properties: GeneralizationProperties, initFn?: (generalization: GeneralizationEditable) => void): this;
	addInterfaceRealization(properties: InterfaceRealizationProperties, initFn?: (interfaceRealization: InterfaceRealizationEditable) => void): this;
	addOwnedAttribute(properties: PropertyProperties, initFn?: (property: PropertyEditable) => void): this;
	addOwnedComment(properties: CommentProperties): this;
	addOwnedOperation(properties: OperationProperties, initFn?: (operation: OperationEditable) => void): this;
}

export interface PropertyEditable extends elements.Property {
	setDefaultValue(value: boolean): this;
	setDefaultValue(value: number): this;
	setDefaultValueNull(): this;
	setDefaultValue(value: string): this;
	setLowerValue(value: number): this;
	setLowerValueUnlimited(): this;
	addOwnedComment(properties: CommentProperties): this;
	setUpperValue(value: number): this;
	setUpperValueUnlimited(): this;
}

export interface PackageEditable extends elements.Package {
	addOwnedComment(properties: CommentProperties): this;
	addPackage(properties: PackageProperties, initFn?: (pack: PackageEditable) => void): this;
	addAssociation(properties: AssociationProperties, initFn?: (association: AssociationEditable) => void): this;
	addClass(properties: ClassProperties, initFn?: (cls: ClassEditable) => void): this;
	addDataType(properties: DataTypeProperties, initFn?: (dataType: DataTypeEditable) => void): this;
	addEnumeration(properties: EnumerationProperties, initFn?: (enumeration: EnumerationEditable) => void): this;
	addPrimitiveType(properties: PrimitiveTypeProperties, initFn?: (primitiveType: PrimitiveTypeEditable) => void): this;
	addInterface(properties: InterfaceProperties, initFn?: (iface: InterfaceEditable) => void): this;
}

export interface DataTypeEditable extends elements.DataType {
	addGeneralization(properties: GeneralizationProperties, initFn?: (generalization: GeneralizationEditable) => void): this;
	addOwnedAttribute(properties: PropertyProperties, initFn?: (property: PropertyEditable) => void): this;
	addOwnedComment(properties: CommentProperties): this;
	addOwnedOperation(properties: OperationProperties, initFn?: (operation: OperationEditable) => void): this;
}

export interface PrimitiveTypeEditable extends elements.PrimitiveType {
	addGeneralization(properties: GeneralizationProperties, initFn?: (generalization: GeneralizationEditable) => void): this;
	addOwnedAttribute(properties: PropertyProperties, initFn?: (property: PropertyEditable) => void): this;
	addOwnedComment(properties: CommentProperties): this;
	addOwnedOperation(properties: OperationProperties, initFn?: (operation: OperationEditable) => void): this;
}

export interface ParameterEditable extends elements.Parameter {
	setDefaultValue(value: boolean): this;
	setDefaultValue(value: number): this;
	setDefaultValueNull(): this;
	setDefaultValue(value: string): this;
	setLowerValue(value: number): this;
	setLowerValueUnlimited(): this;
	addOwnedComment(properties: CommentProperties): this;
	setUpperValue(value: number): this;
	setUpperValueUnlimited(): this;
}

export interface OperationEditable extends elements.Operation {
	addOwnedComment(properties: CommentProperties): this;
	addOwnedParameter(properties: ParameterProperties, initFn?: (parameter: ParameterEditable) => void): this;
}

export interface ModelEditable extends elements.Model {
	addOwnedComment(properties: CommentProperties): this;
	addPackage(properties: PackageProperties, initFn?: (pack: PackageEditable) => void): this;
	addAssociation(properties: AssociationProperties, initFn?: (association: AssociationEditable) => void): this;
	addClass(properties: ClassProperties, initFn?: (cls: ClassEditable) => void): this;
	addDataType(properties: DataTypeProperties, initFn?: (dataType: DataTypeEditable) => void): this;
	addEnumeration(properties: EnumerationProperties, initFn?: (enumeration: EnumerationEditable) => void): this;
	addPrimitiveType(properties: PrimitiveTypeProperties, initFn?: (primitiveType: PrimitiveTypeEditable) => void): this;
	addInterface(properties: InterfaceProperties, initFn?: (iface: InterfaceEditable) => void): this;
}

export interface InterfaceRealizationEditable extends elements.InterfaceRealization {
	addOwnedComment(properties: CommentProperties): this;
}

export interface InterfaceEditable extends elements.Interface {
	addGeneralization(properties: GeneralizationProperties, initFn?: (generalization: GeneralizationEditable) => void): this;
	addOwnedAttribute(properties: PropertyProperties, initFn?: (property: PropertyEditable) => void): this;
	addOwnedComment(properties: CommentProperties): this;
	addOwnedOperation(properties: OperationProperties, initFn?: (operation: OperationEditable) => void): this;
}

export interface GeneralizationEditable extends elements.Generalization {
	addOwnedComment(properties: CommentProperties): this;
}

export interface EnumerationLiteralEditable extends elements.EnumerationLiteral {
	addOwnedComment(properties: CommentProperties): this;
	setSpecification(value: number): this;
	setSpecification(value: string): this;
}

export interface EnumerationEditable extends elements.Enumeration {
	addGeneralization(properties: GeneralizationProperties, initFn?: (generalization: GeneralizationEditable) => void): this;
	addOwnedAttribute(properties: PropertyProperties, initFn?: (property: PropertyEditable) => void): this;
	addOwnedComment(properties: CommentProperties): this;
	addOwnedLiteral(properties: EnumerationLiteralProperties, initFn?: (enumerationLiteral: EnumerationLiteralEditable) => void): this;
	addOwnedOperation(properties: OperationProperties, initFn?: (operation: OperationEditable) => void): this;
}

export interface AssociationEditable extends elements.Association {
	addGeneralization(properties: GeneralizationProperties, initFn?: (generalization: GeneralizationEditable) => void): this;
	addMemberEnd(property: elements.Property): this;
	addOwnedComment(properties: CommentProperties): this;
	addOwnedEnd(properties: PropertyProperties, initFn?: (property: PropertyEditable) => void): this;
}
