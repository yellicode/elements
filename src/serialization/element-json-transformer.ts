/*
* Copyright (c) 2020 Yellicode
*
* This Source Code Form is subject to the terms of the Mozilla Public
* License, v. 2.0. If a copy of the MPL was not distributed with this
* file, You can obtain one at http://mozilla.org/MPL/2.0/.
*/

/**
* This code was generated by a tool.
* 
* Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
*/
import * as elements from '../interfaces';
import { isLiteralUnlimitedNatural } from '../utils';
import { ElementComparer } from '../element-comparer-interface';
import { ElementReferenceResolver } from './element-reference-resolver';

const enumKeys = ['elementType','visibility','aggregation','direction','metaClass','location'];
const regularKeys = ['id','ownedComments','taggedValues','isDeprecated','name','isInferred','isLeaf','generalizations','isAbstract','isFinalSpecialization','isOrdered','isUnique','lowerValue','upperValue','order','isStatic','isReadOnly','ownedAttributes','ownedOperations','interfaceRealizations','isActive','extends','safeName','defaultValue','isDerived','isDerivedUnion','isID','isNavigable','isNamespaceRoot','packagedElements','isException','isStream','ownedParameters','isConstructor','isQuery','value','isSubstitutable','specification','ownedLiterals','body','ownedEnds','isRequired','path','creator','model','modelTypeName','modelTypeVersion','profiles','references'];
const referenceKeys = ['appliedStereotypes','type','appliedProfiles','contract','general','baseType','memberEnds','definition'];

export class ElementJSONTransformer {
	/**
	* Creates a new ElementJSONTransformer instance. You only need an instance when parsing JSON. For
	* serialization, use the static replace function.
	* @param {ElementReferenceResolver} referenceResolver
	* @param {ElementComparer} elementComparer An optional element comparer. Only provide a comparer when
	* sortable elements and packages should be sorted during JSON parsing. This is typically only
	* recommended when generating code and should be avoided when persisting a model (keeping the source
	* data in its original order).
	*/
	constructor(private referenceResolver: ElementReferenceResolver, private elementComparer: ElementComparer | null) {
	}

	public resolveReferences(): void {
		this.referenceResolver.resolve();
	}


	/**
	* Creates a persistable string representation of the specified VisibilityKind value.
	* @param {elements.VisibilityKind} value The value being stringified.
	*/
	private static stringifyVisibilityKind(value: elements.VisibilityKind): string | undefined {
		switch (value)
		{
			case elements.VisibilityKind.public: return 'public';
			case elements.VisibilityKind.private: return 'private';
			case elements.VisibilityKind.protected: return 'protected';
			case elements.VisibilityKind.package: return 'package';
		}
	}

	/**
	* Parses a string representation of the specified VisibilityKind literal value.
	* @param {string} value The value being parsed.
	*/
	private static parseVisibilityKind(value: string): elements.VisibilityKind | undefined {
		switch (value)
		{
			case 'public': return elements.VisibilityKind.public;
			case 'private': return elements.VisibilityKind.private;
			case 'protected': return elements.VisibilityKind.protected;
			case 'package': return elements.VisibilityKind.package;
		}
	}

	/**
	* Creates a persistable string representation of the specified ParameterDirectionKind value.
	* @param {elements.ParameterDirectionKind} value The value being stringified.
	*/
	private static stringifyParameterDirectionKind(value: elements.ParameterDirectionKind): string | undefined {
		switch (value)
		{
			case elements.ParameterDirectionKind.in: return 'in';
			case elements.ParameterDirectionKind.inout: return 'inout';
			case elements.ParameterDirectionKind.out: return 'out';
			case elements.ParameterDirectionKind.return: return 'return';
		}
	}

	/**
	* Parses a string representation of the specified ParameterDirectionKind literal value.
	* @param {string} value The value being parsed.
	*/
	private static parseParameterDirectionKind(value: string): elements.ParameterDirectionKind | undefined {
		switch (value)
		{
			case 'in': return elements.ParameterDirectionKind.in;
			case 'inout': return elements.ParameterDirectionKind.inout;
			case 'out': return elements.ParameterDirectionKind.out;
			case 'return': return elements.ParameterDirectionKind.return;
		}
	}

	/**
	* Creates a persistable string representation of the specified ElementType value.
	* @param {elements.ElementType} value The value being stringified.
	*/
	private static stringifyElementType(value: elements.ElementType): string | undefined {
		switch (value)
		{
			case elements.ElementType.class: return 'class';
			case elements.ElementType.stereotype: return 'stereotype';
			case elements.ElementType.property: return 'property';
			case elements.ElementType.package: return 'package';
			case elements.ElementType.profile: return 'profile';
			case elements.ElementType.dataType: return 'dataType';
			case elements.ElementType.primitiveType: return 'primitiveType';
			case elements.ElementType.parameter: return 'parameter';
			case elements.ElementType.operation: return 'operation';
			case elements.ElementType.model: return 'model';
			case elements.ElementType.literalUnlimitedNatural: return 'literalUnlimitedNatural';
			case elements.ElementType.literalString: return 'literalString';
			case elements.ElementType.literalReal: return 'literalReal';
			case elements.ElementType.literalNull: return 'literalNull';
			case elements.ElementType.literalInteger: return 'literalInteger';
			case elements.ElementType.literalBoolean: return 'literalBoolean';
			case elements.ElementType.interfaceRealization: return 'interfaceRealization';
			case elements.ElementType.interface: return 'interface';
			case elements.ElementType.generalization: return 'generalization';
			case elements.ElementType.enumerationLiteral: return 'enumerationLiteral';
			case elements.ElementType.enumeration: return 'enumeration';
			case elements.ElementType.comment: return 'comment';
			case elements.ElementType.association: return 'association';
		}
	}

	/**
	* Parses a string representation of the specified ElementType literal value.
	* @param {string} value The value being parsed.
	*/
	private static parseElementType(value: string): elements.ElementType | undefined {
		switch (value)
		{
			case 'class': return elements.ElementType.class;
			case 'stereotype': return elements.ElementType.stereotype;
			case 'property': return elements.ElementType.property;
			case 'package': return elements.ElementType.package;
			case 'profile': return elements.ElementType.profile;
			case 'dataType': return elements.ElementType.dataType;
			case 'primitiveType': return elements.ElementType.primitiveType;
			case 'parameter': return elements.ElementType.parameter;
			case 'operation': return elements.ElementType.operation;
			case 'model': return elements.ElementType.model;
			case 'literalUnlimitedNatural': return elements.ElementType.literalUnlimitedNatural;
			case 'literalString': return elements.ElementType.literalString;
			case 'literalReal': return elements.ElementType.literalReal;
			case 'literalNull': return elements.ElementType.literalNull;
			case 'literalInteger': return elements.ElementType.literalInteger;
			case 'literalBoolean': return elements.ElementType.literalBoolean;
			case 'interfaceRealization': return elements.ElementType.interfaceRealization;
			case 'interface': return elements.ElementType.interface;
			case 'generalization': return elements.ElementType.generalization;
			case 'enumerationLiteral': return elements.ElementType.enumerationLiteral;
			case 'enumeration': return elements.ElementType.enumeration;
			case 'comment': return elements.ElementType.comment;
			case 'association': return elements.ElementType.association;
		}
	}

	/**
	* Creates a persistable string representation of the specified DocumentLocationKind value.
	* @param {elements.DocumentLocationKind} value The value being stringified.
	*/
	private static stringifyDocumentLocationKind(value: elements.DocumentLocationKind): string | undefined {
		switch (value)
		{
			case elements.DocumentLocationKind.local: return 'local';
			case elements.DocumentLocationKind.npm: return 'npm';
		}
	}

	/**
	* Parses a string representation of the specified DocumentLocationKind literal value.
	* @param {string} value The value being parsed.
	*/
	private static parseDocumentLocationKind(value: string): elements.DocumentLocationKind | undefined {
		switch (value)
		{
			case 'local': return elements.DocumentLocationKind.local;
			case 'npm': return elements.DocumentLocationKind.npm;
		}
	}

	/**
	* Creates a persistable string representation of the specified AggregationKind value.
	* @param {elements.AggregationKind} value The value being stringified.
	*/
	private static stringifyAggregationKind(value: elements.AggregationKind): string | undefined {
		switch (value)
		{
			case elements.AggregationKind.none: return 'none';
			case elements.AggregationKind.shared: return 'shared';
			case elements.AggregationKind.composite: return 'composite';
		}
	}

	/**
	* Parses a string representation of the specified AggregationKind literal value.
	* @param {string} value The value being parsed.
	*/
	private static parseAggregationKind(value: string): elements.AggregationKind | undefined {
		switch (value)
		{
			case 'none': return elements.AggregationKind.none;
			case 'shared': return elements.AggregationKind.shared;
			case 'composite': return elements.AggregationKind.composite;
		}
	}

	/**
	* A custom replacer function that is used as a replacer callback using JSON.stringify.
	* @param {elements.Element | any} element The model element or nested object in which the key was
	* found.
	* @param {any} key The key being stringified.
	* @param {any} value The value being stringified.
	* @param {boolean} valueIsArray True if the value being stringified is an array.
	*/
	public static toJSON(element: elements.Element | any, key: any, value: any, valueIsArray: boolean): any {
		if (value == null) return undefined;

		if (regularKeys.indexOf(key) > -1)
			return (key === 'value') ? (element as elements.ValueSpecification).getStringValue() : value;

		if (referenceKeys.indexOf(key) > -1) {
			if (valueIsArray) {
				return value.map((e: elements.Element) => e.id);
			}
			else return (value as elements.Element).id;
		}
		if (enumKeys.indexOf(key) > -1) {
			switch (key)
			{
				case 'elementType': return ElementJSONTransformer.stringifyElementType(value);
				case 'visibility': return ElementJSONTransformer.stringifyVisibilityKind(value);
				case 'aggregation': return ElementJSONTransformer.stringifyAggregationKind(value);
				case 'direction': return ElementJSONTransformer.stringifyParameterDirectionKind(value);
				case 'metaClass': return ElementJSONTransformer.stringifyElementType(value);
				case 'location': return ElementJSONTransformer.stringifyDocumentLocationKind(value);
			}
		}
	}

	/**
	* A custom mapper function that maps a JSON property value to a valid element value.
	* @param {elements.Element | any} element The model element or nested object in which the key was
	* found.
	* @param {any} key The key being parsed.
	* @param {any} value The value being parsed.
	*/
	public fromJSON(element: elements.Element | any, key: any, value: any): any {
		if (regularKeys.indexOf(key) > -1) {
			switch (key)
			{
				case 'value': return isLiteralUnlimitedNatural(element) ? new elements.UnlimitedNatural(value) : value;
				case 'packagedElements': return this.elementComparer ? (value as elements.PackageableElement[]).sort(this.elementComparer.comparePackageableElements) : value;
				case 'ownedAttributes':
				case 'ownedOperations':
				case 'ownedParameters':
				case 'ownedLiterals':
				case 'ownedEnds':
					return this.elementComparer ? (value as (elements.OrderedElement & elements.NamedElement)[]).sort(this.elementComparer.compareOrderedElements) : value;
				default: return value;
			}
		}

		if (referenceKeys.indexOf(key) > -1) {
			this.referenceResolver.addUnResolvedReference(key, element, value);
			return; // return no value, it will be resolved later
		}

		if (enumKeys.indexOf(key) > -1) {
			switch (key)
			{
				case 'visibility': return ElementJSONTransformer.parseVisibilityKind(value);
				case 'aggregation': return ElementJSONTransformer.parseAggregationKind(value);
				case 'direction': return ElementJSONTransformer.parseParameterDirectionKind(value);
				case 'metaClass': return ElementJSONTransformer.parseElementType(value);
				case 'location': return ElementJSONTransformer.parseDocumentLocationKind(value);
			}
		}
	}
}
